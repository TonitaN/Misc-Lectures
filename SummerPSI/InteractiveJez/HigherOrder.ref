/* Given a sequence of (possibly curried) functions f1 ... fn, and an arg a, returns <fn...<f2 <f1 a>>..> */
MapCompose {
  ((e.Call) e.RestCalls) e.Arg = <MapCompose (e.RestCalls) <Mu e.Call e.Arg>>;
  (/* EMPTY */) e.Arg = e.Arg;
}

/* Given an arg and a (possibly curried) function, applies the function to the arg: \x f_A -> <f A x> */
Flip {
   e.FreeArg (s.Fun e.CurriedArg) = <Mu s.Fun e.CurriedArg e.FreeArg>; /* Function with curried arguments */
   e.FreeArg s.Fun = <Mu s.Fun e.FreeArg>; /* Not curried, plain function */
}

/* \f_A xs -> map f_A xs */
MapCall {
   Curry (s.FunctionName e.Args) t.Element e.List /* Some first args are curried */
       = <Mu s.FunctionName e.Args t.Element> <MapCall Curry (s.FunctionName e.Args) e.List>;
   Revert (s.FunctionName e.Args) t.Element e.List /* Some last args are "curried" (impossible in Haskell-style langs w/o associativity) */
       = <Mu s.FunctionName t.Element e.Args> <MapCall Revert (s.FunctionName e.Args) e.List>;
   Plain s.FunctionName t.Element e.List /* A bare function is applied, no curried arguments are given */
       = <Mu s.FunctionName t.Element> <MapCall Plain s.FunctionName e.List>;
   s.AnyMode t.ToApply /* No args */ = /* Empty list */;
}

/* Given a set of pairs (f1 x1) ... (fn xn), where fi is the function identifier, "unfreezes" fi: <f1 x1> ... <fn xn> */
UnwrapCalls {
 (s.FunctionName e.Data) e.MuList
  = <Mu s.FunctionName e.Data> <UnwrapCalls e.MuList>;
 ((s.FunctionName e.Curried) e.Data) e.MuList
  = <Mu s.FunctionName e.Curried e.Data> <UnwrapCalls e.MuList>;
 /* No more pairs */ = /* EMPTY */;
}

/*
  Calls the given function till it returns expected result. If different result
  is recieved, immediately returns it. Otherwise, returns the expected one.
*/
CallTill {
  (e.ExpectedResult) Curry (s.Function e.Arguments) t.Element e.List
    , <Mu s.Function e.Arguments t.Element> : {
      e.ExpectedResult
        = <CallTill (e.ExpectedResult) Curry (s.Function e.Arguments) e.List>;

      e.OtherResult = e.OtherResult;
    };
    
  (e.ExpectedResult) Revert (s.Function e.Arguments) t.Element e.List
    , <Mu s.Function t.Element e.Arguments> : {
      e.ExpectedResult
        = <CallTill (e.ExpectedResult) Revert (s.Function e.Arguments) e.List>;

      e.OtherResult = e.OtherResult;
    };
    
  (e.ExpectedResult) Plain s.Function t.Element e.List
    , <Mu s.Function t.Element> : {
      e.ExpectedResult = <CallTill (e.ExpectedResult) Plain s.Function e.List>;

      e.OtherResult = e.OtherResult;
    };

  (e.ExpectedResult) s.AnyMode t.Function /* Empty list */ = e.ExpectedResult;
}

/* Given a call with arguments, requiring reading from a file, and a datum from the file, determine whether the call is to be executed */
ContinueIfNotEOF {
  (e.Function) e.Data 0 = /* No action */;
  (e.Function) e.Data = <UnwrapCalls (e.Function)>;
}

/*
  <MapCall-Compose (e.Call) (e.CompArgs) e.Elems>
    == e.NewElems e.NewCompArgs

  For given (possibly curried) function f, composition argument x and
  elements y1, y2, ..., yn calculates

    <f x   y1>    = x'   y1'
    <f x'  y2>    = x''  y2'
    <f x'' y3>    = x''' y3'
    ........................
    <f x(n-1) yn> = x(n) yn'
    
  and returns y1' y2' ... yn' x(n). Function f must have the following format:
  
    <f e.Args e.CompArgs t.List> == e.NewCompArgs t.NewList
*/
MapCall-Compose {
  (e.Call) (e.CompArgs) e.Elems
    , e.Elems : {
      t.Elem e.RestElems
        , <Mu e.Call e.CompArgs t.Elem> : e.NewCompArgs t.NewElem
        = t.NewElem <MapCall-Compose (e.Call) (e.NewCompArgs) e.RestElems>;

      /* empty */ = e.CompArgs;
    };
}

FormTerm {
  e.Any = (e.Any);
}

