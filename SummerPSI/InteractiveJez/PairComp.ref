$ENTRY Go {
  = <Prout <MapCall Plain RunPairComp <TestSet-PairComp>>>;
}

/*
  <TestSet-PairComp>
    == (s.SeqNumber (e.NewConst) (e.Const1) (e.Const2) (e.Eq)) e.Tests
*/
TestSet-PairComp {
  = (
      1
      ('A' 1)
      ('B' 0) ('A' 0)
      (
        (
          AreEqual
          ((Var 'X') ('B' 0) (Var 'Y') ('A' 0))
          ((Var 'Y') (Var 'Y') ('B' 0) ('A' 0) (Var 'X'))
        )
        (
          (OR (not empty (Var 'X')))
        )
        (/* No index equations */)
      )
    )
    (
      2
      ('A' 1)
      ('A' 0) ('B' 0)
      (
        (
          AreEqual
          ((Var 'X') ('A' 0) ('B' 0) (Var 'Y'))
          ((Var 'Y') ('B' 0) ('A' 0) (Var 'X'))
        )
        (
          (OR (not empty (Var 'Y')))
        )
        (/* No index equations */)
      )
    )
    (
      3
      ('A' 1)
      ('A' 0) ('B' 0)
      (
        (
          AreEqual
          (('B' 0) (Var 'X') (Var 'Y') ('A' 0))
          ((Var 'X') ('B' 0) (Var 'Z') (Var 'Y'))
        )
        (/* No constraints */)
        (/* No index equations */)
      )
    );
}

/*
  <RunPairComp (s.SeqNumber) (e.NewConst) (e.Const1) (e.Const2) (e.Eq)>
    == True
    == False
*/
RunPairComp {
  /* TODO: fix tests */
  (1 e.Input)
    , <PairComp e.Input> : {
      ('B' 1) (e.NewEqs)
        , e.NewEqs
        : e.L1
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y') ('A' 1))
              (('A' 0) (Var 'Y') ('A' 1) (Var 'Y') ('B' 0) ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          (
            (
              AreEqual
              ((Var 'X') ('B' 0) (Var 'Y') ('A' 1))
              ((Var 'Y') ('B' 0) (Var 'Y') ('B' 0) ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
              (OR (not ('A' 0) starts (Var 'Y')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              (('A' 0) (Var 'Y') ('A' 0) (Var 'Y') ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
              (OR (not ('B' 0) ends (Var 'Y')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          (
            (
              AreEqual
              ((Var 'X') ('B' 0) (Var 'Y') ('A' 0))
              ((Var 'Y') (Var 'Y') ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
              (OR (not empty (Var 'Y')))
              (OR (not ('B' 0) ends (Var 'Y')))
              (OR (not ('A' 0) starts (Var 'Y')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R4
        , e.L4 e.R4
        : e.L5
          (
            (
              AreEqual
              ((Var 'X') ('A' 1))
              (('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
            )
            (/* No Conditions */)
          )
          e.R5
        = True;
        
        e.Other = False;
    };
    
  (2 e.Input)
    , <PairComp e.Input> : {
      ('B' 1) (e.NewEqs)
        , e.NewEqs
        : e.L1
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'Y') ('A' 1) ('A' 1) (Var 'X'))
            )
            (/* No constraints */)
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'Y') ('A' 1) ('A' 0) (Var 'X'))
            )
            (
              (OR (not ('B' 0) starts (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y'))
              ((Var 'Y') ('B' 0) ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'Y')))
              (OR (not ('A' 0) ends (Var 'Y')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y'))
              ((Var 'Y') ('B' 0) ('A' 0) (Var 'X'))
            )
            (
              (OR (not empty (Var 'Y')))
              (OR (not ('A' 0) ends (Var 'Y')))
              (OR (not ('B' 0) starts (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R4
        = True;
        
        e.Other = False;
    };
    
  (3 e.Input)
    , <PairComp e.Input> : {
      ('B' 1) (e.NewEqs)
        , e.NewEqs
        : e.L1
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'X') ('A' 1) (Var 'Z') ('A' 1) (Var 'Y'))
            )
            (/* No constraints */)
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'X') ('A' 1) (Var 'Z') ('B' 0) (Var 'Y'))
            )
            (
              (OR (not ('A' 0) ends (Var 'Z')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 0) (Var 'Y') ('A' 0))
              ((Var 'X') ('A' 1) (Var 'Z') (Var 'Y'))
            )
            (
              (OR (not ('B' 0) starts (Var 'Y')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('B' 0) (Var 'Y') ('A' 0))
              ((Var 'X') ('B' 0) (Var 'Z') ('A' 1) (Var 'Y'))
            )
            (
              (OR (not ('A' 0) ends (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R4
        , e.L4 e.R4
        : e.L5
          (
            (
              AreEqual
              (('B' 0) (Var 'X') (Var 'Y') ('A' 0))
              ((Var 'X') ('B' 0) (Var 'Z') (Var 'Y'))
            )
            (
              (OR (not ('A' 0) ends (Var 'X')))
              (OR (not ('A' 0) ends (Var 'Z')) (not ('B' 0) starts (Var 'Y')))
            )
            (/* No index equations */)
          )
          e.R5
        = True;
        
      e.Other = False;
    };
}

/*
  <PairComp t.ReplacingConst t.Const1 t.Const2 t.Equation>
    == t.NewReplacingConst (e.Equations)
*/
PairComp {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    = <GetNewConst t.ReplacingConst>
      (
        <HandleEmptySubsts
          t.ReplacingConst t.Const1 t.Const2 t.Equation
        >
      );
}

/*
  If an essentially empty substitution is possible, recursively calls itself
  with an applied and not applied substitution equations. Otherwise, transfers
  control to the `HandleNonEmptySubsts` function.
  
  <HandleEmptySubst
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    /* Calling `GetEmptySubst` is quite expensive, so here's
       used `CallTill` not to make redundant calculations with `MapCall` */
    , <CallTill
        (/* EMPTY */)
        Curry
        (
          GetEmptySubst
          t.Const1 t.Const2 (e.Constraints)
        )
        (e.LHS) (e.RHS)
      >
    : {
      /* Found an essentially empty substitution */
      t.Subst
        = /* Calling with performed substitution */
          <HandleEmptySubsts 
            t.ReplacingConst t.Const1 t.Const2
            (
              (
                AreEqual
                <MapCall Curry (Subst (t.Subst)) (e.LHS) (e.RHS)>
              )
              (e.Constraints)
              (e.Conditions)
            )
          >
          /* Calling with not performed substitution */
          <HandleEmptySubsts
            t.ReplacingConst t.Const1 t.Const2
            (
              (AreEqual (e.LHS) (e.RHS))
              (e.Constraints (OR <GenSubstDenial t.Subst>))
              (e.Conditions)
            )
          >;
      
      /* No essentially empty substitution is found. */
      /* EMPTY */
        = <HandleNonEmptySubsts
            t.ReplacingConst t.Const1 t.Const2 t.Equation
          >;
    };
}

/*
  Returns any essentially empty substitution possible in the given equation
  half. If no such substitution is found, returns ε.
  
  <GetEmptySubst
    t.Const1 t.Const2 (e.Constraints) (e.EquationHalf)
  >
    == t.Subst
    == ε
*/
GetEmptySubst {
  t.Const1 t.Const2 (e.Constraints) (e.EquationHalf)
    /* Saving the result of frequently called functions */
    , <VarAlphabet> : e.Vars
    , <GetNonEmptyVars e.Constraints> : e.NonEmptyVars
    , e.EquationHalf : {
      e.L t.Const1 e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            (e.Vars)
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;
        
      e.L t.Const1 e.M (Var s.X) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;

      e.L (Var s.X) e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;

      e.L (Var s.X) e.M  (Var s.Y) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X) (Var s.Y))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;
        
      /* No essentially empty substitutions for this half of the equation */
      e.Other = /* EMPTY */;
    };
}

/* Finds and applies essentially non-empty substitutions to the equation. 
  
  <HandleNonEmptySubsts
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleNonEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    , <GetNonEmptySubsts /* substitutions for the right half */
        t.Const1 t.Const2 (e.Constraints) (e.Conditions)
        <GetNonEmptySubsts /* substitutions for the left half */
          t.Const1 t.Const2 (e.Constraints) (e.Conditions)
          (/* No discovered elementary substitutions at start */)
          (/* No discovered composite substitutions at start */)
          (e.LHS)
        >
        (e.RHS)
      > : (e.ElementarySubsts) (e.CompositeSubsts)
    , <CartesianProductOfOptionSets
        <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
      >
    : (e.MultipliedOptions) /* what if no options initially? */
    , <MapCall
        Curry
        (ProcessOption (e.Conditions))
        e.MultipliedOptions
      > : {
      /* No implicit occurences. Applying empty option to the equation. */
      /* EMPTY */
        = <ApplyOption
            t.ReplacingConst t.Const1 t.Const2 t.Equation
            ((/* No substitutions */)(/* No constraints */))
          >;

      e.ProcessedOptions
        = <MapCall
            Curry
            (ApplyOption t.ReplacingConst t.Const1 t.Const2 t.Equation)
            e.ProcessedOptions
          >;
    };
}

/*
  Returns essentially non-empty substitutions for the given equation half.
  There are no impossible substitutions among returned.
  
  <GetNonEmptySubst
    t.Const1 t.Const2 (e.Constraints) (e.Conditions)
    (e.DiscoveredElementarySubsts) (e.DiscoveredCompositeSubsts) (e.Elems)
  >
    == e.Substs
*/
GetNonEmptySubsts {
  t.Const1 t.Const2 (e.Constraints) (e.Conditions)
  (e.ElementarySubsts) (e.CompositeSubsts) (e.Elems)
    , e.Elems : {
      (Var s.X) (Var s.Y) e.RestElems
        , <GenSubst ((Var s.X)) ((Var s.X) t.Const1)> : t.Subst1
        , <GenSubst ((Var s.Y)) (t.Const2 (Var s.Y))> : t.Subst2
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.Y) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts (t.Subst1 t.Subst2))
            ((Var s.Y) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet (t.Subst1 t.Subst2) (e.CompositeSubsts)> : {
            /* The substitution is already processed. */
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.ConstX ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.ConstX
                      (t.Const1 <GetLast t.Const1 (e.Conditions)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False
                        ,  e.L e.R : {
                          e.L1 (OR (not t.ConstY starts (Var s.Y))) e.R1
                            , <IsElemInSet
                                t.ConstY
                                (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                              > : {
                                /* The substitution is impossible. */
                                True = <UnwrapCalls t.SkipSubst>;

                                False = <UnwrapCalls t.AddSubst>;
                              };
                          
                          /* No constraint on the substitution. */
                          e.L e.R = <UnwrapCalls t.AddSubst>;
                        };
                    };

                /* No constraint on the first substitution. */
                e.L (OR (not t.ConstY starts (Var s.Y))) e.R
                  , <IsElemInSet
                      t.ConstY
                      (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;

                      False = <UnwrapCalls t.AddSubst>;
                    };

                /* No constraints on the substitutions. */
                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Const1 (Var s.X) e.RestElems
        , <GenSubst ((Var s.X)) (t.Const2 (Var s.X))> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.Const starts (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };
        
      (Var s.X) t.Const2 e.RestElems
        , <GenSubst ((Var s.X)) ((Var s.X) t.Const1)> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            (e.RestElems) /* can skip t.Const2 */
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            (e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.Const ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const1 <GetLast t.Const1 (e.Conditions)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Elem1 t.Elem2 e.RestElems
        = <GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            (t.Elem2 e.RestElems)
          >;

      e.OneOrNoTerm = (e.ElementarySubsts) (e.CompositeSubsts);
    };
}

/*
  <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
    == e.OptionSets
*/
GenOptionSets {
  (e.ElementarySubsts) (e.CompositeSubsts)
    , <GetUniqueValues
        Flat
        <MapCall
          Revert
          (GetSpecialSubsts (e.ElementarySubsts))
          e.CompositeSubsts
        >
      >
    : e.SpecialSubsts
    , <SubtractSets (e.ElementarySubsts) (e.SpecialSubsts)>
    : (e.UnprocessedElementarySubsts)
    = <MapCall
        Revert
        (GenCompositeOptionSet (e.SpecialSubsts))
        e.CompositeSubsts
      >
      <MapCall
        Plain
        GenElementaryOptionSet
        e.UnprocessedElementarySubsts
      >;
}

/*
  For the equation, we call an essential elementary substitution "special"
  if it is present in some essential composite substitution.

  Returns special substitutions of the given composite substitution.
  
  <GetSpecialSubsts t.CompositeSubst (e.ElementarySubsts)>
    == e.SpecialSubsts
*/
GetSpecialSubsts {
  (t.Subst1 t.Subst2) (e.ElementarySubsts)
    , e.ElementarySubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is special too. */
          e.L1 t.Subst2 e.R1 = t.Subst1 t.Subst2;

          /* Only the first substitution is special. */
          e.Other = t.Subst1;
        };

      /* Only the second substitution is special. */
      e.L t.Subst2 e.R = t.Subst2;

      /* None of the substitutions are special. */
      e.Other = /* EMPTY */;
    };
}

/*
  We will call an option set composite if it is obtained from a composite
  substitution. 
  
  <GenCompositeOptionSet t.CompositeSubst (e.SpecialSubsts)>
    == e.OptionSet
*/
GenCompositeOptionSet {
  (t.Subst1 t.Subst2) (e.SpecialSubsts)
    , e.SpecialSubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is special too. */
          e.L1 t.Subst2 e.R1
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
                (
                  (t.Subst2)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
              );

          /* Only the first substitution is special. */
          e.Other
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                  )
                )
              );
        };

      /* Only the second substitution is special. */
      e.L t.Subst2 e.R
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (t.Subst2)
              (
                (OR <GenSubstDenial t.Subst1>)
              )
            )
            (
              (/* No substitutions */)
              (
                (OR <GenSubstDenial t.Subst2>)
              )
            )
          );

      /* None of the substitutions are special. */     
      e.Other
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (/* No substitutions */)
              (
                (
                  OR
                  <GenSubstDenial t.Subst1>
                  <GenSubstDenial t.Subst2>
                )
              )
            )
          );
    };
}

/*
  We will call an option set elementary if it is obtained from an elementary
  substitution. 
  
  <GenElementaryOptionSet t.ElementarySubst>
    == e.OptionSet
*/
GenElementaryOptionSet {
  t.Subst
    = (
        (
          (t.Subst)
          (/* No constraints */)
        )
        (
          (/* No substitutions */)
          (
            (OR <GenSubstDenial t.Subst>)
          )
        )
      );
}

/*
  Removes duplicates, redundant constraints and checks the option for
  consistency.
  
  <ProcessOption (e.Conditions) t.Option>
    == t.ProcessedOption
    == ε
*/
ProcessOption {
  (e.Conditions) ((e.Substs) (e.Constraints))
    , <MapCall
        Curry
        (GetUniqueValues Wrap)
        (e.Substs) (e.Constraints)
      > : (e.UniqueSubsts) (e.UniqueConstraints)
    , <RemoveTrivialConstraints
        (e.UniqueConstraints)
        (e.Conditions)
      > : e.NecessaryConstraints
    = <FixOptionConsistency
        ((e.UniqueSubsts) (e.NecessaryConstraints))
        (/* No checked substitutions at start */)
        (e.Conditions)
      >;
}

/*
  Removes trivially performed non-trivial disjuncts.
  
  <RemoveTrivialConstraints (e.Constraints) (e.Conditions)>
    == e.NecessaryConstraints
*/
RemoveTrivialConstraints {
  (e.Constraints) (e.Conditions)
    , e.Constraints : {
      e.L (OR (not t.Const1 ends t.VarX) (not t.Const2 starts t.VarY)) e.R
        , e.L e.R : {
          e.L1 (OR (not t.ConstX ends t.VarX)) e.R2
            , <IsElemInSet t.ConstX
                (t.Const1 <GetLast t.Const1 (e.Conditions)>)
              > : True /* found stronger restriction */
            = e.L <RemoveTrivialConstraints (e.R) (e.Conditions)>;
                
          e.L1 (OR (not t.ConstY starts t.VarY)) e.R2
            , <IsElemInSet
                t.ConstY
                (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
              > : True
            = e.L <RemoveTrivialConstraints (e.R) (e.Conditions)>;

          e.L e.R /* cannot say whether the disjunct is redundant or not */
            = e.L (OR (not t.Const1 ends t.VarX) (not t.Const2 starts t.VarY))
              <RemoveTrivialConstraints (e.R) (e.Conditions)>;
        };
        
      e.TrivialDisjuncts = e.TrivialDisjuncts;
    };
}

/*
  Checks an option for consistency and fixes avoidable contradictions
  whenever necessary. If an unavoidable contradiction is found, returns ε.
  Otherwise, returns the processed option.
  
  <FixOptionConsistency t.Option (e.CheckedSubsts) (e.Conditions)>
    == t.FixedOption
    == ε
*/
FixOptionConsistency {
  ((e.UncheckedSubsts) (e.Constraints)) (e.CheckedSubsts) (e.Conditions)
    , e.UncheckedSubsts : {
      (assign (t.Var) (t.Var t.Const)) e.RestSubsts /* suffix substitution */
      , e.Constraints : {
        e.L (OR (not t.RestrConst ends t.Var) e.AnotherRestr) e.R
          , <IsElemInSet
              t.RestrConst
              (t.Const <GetLast t.Const (e.Conditions)>)
            > : True
          , e.AnotherRestr : {
            /* EMPTY */ = /* EMPTY */; /* unavoidable contradiction */

            t.Restr /* force another restriction to be executed */
              = <FixOptionConsistency
                  ((e.UncheckedSubsts) (e.L (OR t.Restr) e.R))
                  (e.CheckedSubsts) (e.Conditions)
                >;
          };
        
        /* No constraints on the substitution. */
        e.CheckedConstraints
          = <FixOptionConsistency
              ((e.RestSubsts) (e.CheckedConstraints))
              (e.CheckedSubsts (assign (t.Var) (t.Var t.Const)))
              (e.Conditions)
            >;
      };

      (assign (t.Var) (t.Const t.Var)) e.RestSubsts /* prefix substitution */
        , e.Constraints : {
          e.L (OR e.AnotherRestr (not t.RestrConst starts t.Var)) e.R
            , <IsElemInSet
                t.RestrConst
                (t.Const <GetFirst t.Const (e.Conditions)>)
              > : True
            , e.AnotherRestr : {
              /* EMPTY */ = /* EMPTY */;

              t.Restr
                = <FixOptionConsistency
                    ((e.UncheckedSubsts) (e.L (OR t.Restr) e.R))
                    (e.CheckedSubsts) (e.Conditions)
                  >;
            };

          e.CheckedConstraints
            = <FixOptionConsistency
                ((e.RestSubsts) (e.CheckedConstraints))
                (e.CheckedSubsts (assign (t.Var) (t.Const t.Var)))
                (e.Conditions)
              >;
        };
        
      /* All the substitutions are checked. */
      /* EMPTY */ = ((e.CheckedSubsts) (e.Constraints));
    };
}

/*
  Applies option substitutions to the equation (also adds corresponding index
  equation) and appends the option constraints to the equation constraints.
  Thereafter trimmes this equation, removes redundant elements and modifies
  constraints.
  
  <ApplyOption t.ReplacingConst t.Const1 t.Const2 t.Equation t.Option>
    == t.NewEquation
*/
ApplyOption {
  t.ReplacingConst t.Const1 t.Const2
  ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
  ((e.Substs) (e.NewConstraints))
    , <MapCall /* replacing the pairs with the new const */
        Curry
        (Subst (<GenSubst (t.Const1 t.Const2) (t.ReplacingConst)>))
        <MapCall /* applying the option substitutions */
          Curry
          (Subst (e.Substs))
          (e.LHS) (e.RHS)
        >
      > : (e.SubstLHS) (e.SubstRHS)
    , <MapCompose
        ((TrimEquation Left) (TrimEquation Right))
        ((AreEqual (e.SubstLHS) (e.SubstRHS)) (e.Constraints) (e.Conditions))
      > : ((AreEqual (e.TrimmedLHS) (e.TrimmedRHS)) e.Rest)
    , <GetUniqueValues
        Flat
        <MapCall Plain GetConsts (e.TrimmedLHS) (e.TrimmedRHS)>
      >: e.EqConsts
    , <RemoveRedundantConditions
        (e.EqConsts)
        (
          e.Conditions
          (t.ReplacingConst is (t.Const1 (const 1)) (t.Const2 (const 1)))
        )
        (/* EMPTY */)
      > : e.NecessaryConditions 
    , <RemoveRedundantRestrictions
        (e.EqConsts) (e.NecessaryConditions) (e.Constraints) (/* EMPTY */)
      > : e.NecessaryConstraints
    , <ModifyRestrictions
        (e.Substs) (e.NecessaryConstraints e.NewConstraints)
        (e.NecessaryConditions)
      > : e.ModifiedConstraints
    =
      (
        (AreEqual (e.TrimmedLHS) (e.TrimmedRHS))
        (e.ModifiedConstraints) (e.NecessaryConditions)
      );
}

/*
  TODO: fix the cycling

  Modifies constraints taking into account the substitutions.
  
  <ModifyRestrictions (e.Substs) (e.Constraints) (e.Conditions)>
    == e.ModifiedConstraints
*/
ModifyRestrictions {
  (e.Substs) (e.Constraints) (e.Conditions)
    , e.Substs : {
      (assign (t.Var) (t.Const t.Var)) e.RestSubsts
        , e.Constraints : { /* the order of the rules is important here */
          e.L (OR (not empty t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;

          /* Thanks to the GetNonEmptySubsts the t.PrefixConst is definitely
             not in the First(t.Const) set. */
          e.L (OR (not t.PrefixConst starts t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;

          e.L (OR t.SuffixRestr (not t.PrefixConst starts t.Var)) e.R
            , <IsElemInSet
                t.PrefixConst
                (<GetFirst t.Const (e.Conditions)>)
              > : {
              True /* forcing the suffix restriction to be executed */
                = <ModifyRestrictions
                    (e.RestSubsts) /* pay attention that we're moving on */
                    (e.L (OR t.SuffixRestr) e.R) (e.Conditions)
                  >;

              False /* cannot say anything definite, moving on */
                = <ModifyRestrictions
                    (e.RestSubsts) (e.Constraints) (e.Conditions)
                  >;
            };

          e.Other /* moving on */
            = <ModifyRestrictions
                (e.RestSubsts) (e.Constraints) (e.Conditions)
              >;
        };
      
      (assign (t.Var) (t.Var t.Const)) e.RestSubsts
        , e.Constraints : {
          e.L (OR (not empty t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;
            
          e.L (OR (not t.SuffixConst ends t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;

          e.L (OR (not t.SuffixConst ends t.Var) t.PrefixRestr) e.R
            , <IsElemInSet
                t.SuffixConst
                (<GetLast t.Const (e.Conditions)>)
              > : {
              True
                = <ModifyRestrictions
                    (e.RestSubsts) (e.L (OR t.PrefixRestr) e.R) (e.Conditions)
                  >;

              False
                = <ModifyRestrictions
                    (e.RestSubsts) (e.Constraints) (e.Conditions)
                  >;
            };

          e.Other
            = <ModifyRestrictions
                (e.RestSubsts) (e.Constraints) (e.Conditions)
              >;
        };
        
      /* EMPTY */ = e.Constraints;
    };
}

