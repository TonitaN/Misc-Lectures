*$INLINE HigherOrder;

/*
  DATA STRUCTURES.
  
  t.Equation
    ::= ((AreEqual (t.Element*) (t.Element*)) (t.Constraint*) (t.Condition*))

  t.Element  ::= t.Constant | t.Variable
  t.Constant ::= (s.LETTER s.NUMBER)
  t.Variable ::= (Var s.LETTER)

  t.Constraint ::= (OR t.Restriction+)
  t.Restriction
    ::= (not empty t.Variable) |
        (not t.Constant starts t.Variable) |
        (not t.Constant ends t.Variable)

  t.Condition ::= (t.Constant is t.Factor+)
  t.Factor    ::= (t.Constant t.Exponent* (const s.NUMBER))
  t.Exponent  ::= (s.WORD s.NUMBER)

  e.OptionSet    ::= (t.Option*)
  t.Option       ::= ((t.Substitution*) (t.Constraint*) (t.Constraint*))
  t.Substitution ::= (assign (e.ANY) (e.ANY))

  ABBREVIATIONS.
  
  eq    == equation
  restr == restriction
  const == constant
  var   == variable
  subst == substitution
  acc   == accumulator
*/

$EXTERN FormPair, Zip, Take, GetNewConst, IsWordInAlphabet, IsEmpty,
        LatinCapitalLetters, SubtractSets, GetUniqueValues, QuickSort,
        Partition, Overlap, IsElemInSet, FormTerm, GetNewIndex;
        
$ENTRY Go {
  = <Prout
      <MapCall
        Curry
        (Flip <TestSet-Pick>)
        <MapCall Curry (FormPair RunPick) 1 2 3 4>
      >
    >
    <Prout
      <UnwrapCalls
        <Zip
          (
            <MapCall
              Curry
              (FormPair RunSubstIndices)
              (
                1
                (SubstIndex i1 ((i2 2) (const 2)))
              )
              (
                2
                (SubstIndex i4 ((i1 3) (const 1)))
                (SubstIndex i1 ((i2 2) (i3 1) (const 0)))
              )
              (
                3
                (SubstIndex i4 ((i1 3) (const 1)))
                (SubstIndex i1 ((i2 2) (i3 1) (const 0)))
              )
              (
                4
                (SubstIndex i4 ((i1 3) (const 1)))
                (SubstIndex i1 ((i2 2) (i3 1) (const 0)))
              )
            >
          )
          (<TestSet-SubstIndex>)
        >
      >
    >
    <Prout
      <MapCall Plain RunPairComp <TestSet-PairComp>>
    >
    <Prout
      <MapCall Plain Run-BlockComp <TestSet-BlockComp>>
    >;
}

TestSet-Pick {
  = (
      (
        AreEqual
        ((Var 'X') ('A' 0))
        ((Var 'Y') ('B' 0) (Var 'Y'))
      )
      (/* No constraints */)
      (/* No index eqs */)
    )
    (
      (
        AreEqual
        (('A' 0) (Var 'X') ('A' 0))
        ((Var 'Y') ('A' 0) ('A' 0) (Var 'Y'))
      )
      (
        (OR (not empty (Var 'X')))
        (OR (not ('A' 0) starts (Var 'X')) (not ('B' 0) ends (Var 'X')))
      )
      (/* No index eqs */)
    )
    (
      (
        AreEqual
        ((Var 'X'))
        ((Var 'Y'))
      )
      (
        (OR (not empty (Var 'X')))
      )
      (/* No index eqs */)
    )
    (
      (
        AreEqual
        ((Var 'X') ('A' 0))
        (('A' 0) (Var 'Y'))
      )
      (
        (OR (not ('A' 0) ends (Var 'X')))
      )
      (/* No index eqs */)
    );
}

TestSet-SubstIndex {
  = (
      (
        AreEqual
        (('A' 2))
        (('A' 1) (Var 'X') ('A' 1))
      )
      (
        (OR (not empty (Var 'X')))
      )
      (
        (('A' 1) is (('A' 0) (i1 1) (const 0)))
        (('A' 2) is (('A' 0) (i2 2) (const 2)))
      )
    )
    (
      (
        AreEqual
        (('A' 3) (Var 'Y') ('A' 3))
        (('A' 2) (Var 'X') ('A' 1))
      )
      (/* No constraints */)
      (
        (('A' 1) is (('A' 0) (i1 3) (const 1)))
        (('A' 2) is (('A' 0) (i2 6) (i3 3) (const 1)))
        (('A' 3) is (('A' 0) (i4 1) (const 0)))
      )
    )
    (
      (
        AreEqual
        (('A' 3) (Var 'Y')('A' 1)(Var 'Y'))
        (('A' 2) (Var 'X'))
      )
      (/* No constraints */)
      (
        (('A' 1) is (('A' 0) (i1 3) (const 1)))
        (('A' 2) is (('A' 0) (i2 5) (i3 3) (const 1)))
        (('A' 3) is (('A' 0) (i4 1) (const 0)))
      )
    )
    (
      (
        AreEqual
        (('A' 3) ('B' 0) (Var 'X') ('A' 3) (Var 'Y'))
        (('A' 2) ('B' 0) (Var 'X') (Var 'Z') ('A' 2))
      )
      (/* No constraints */)
      (
        (('A' 1) is (('A' 0) (i1 3) (const 1)))
        (('A' 2) is (('A' 0) (i2 6) (i3 3) (const 1)))
        (('A' 3) is (('A' 0) (i4 1) (const 0)))
      )
    );
}

/*
  <TestSet-PairComp>
    == (s.SeqNumber (e.NewConst) (e.Const1) (e.Const2) (e.Eq)) e.Tests
*/
TestSet-PairComp {
  = (
      1
      ('A' 1)
      ('B' 0) ('A' 0)
      (
        (
          AreEqual
          ((Var 'X') ('B' 0) (Var 'Y') ('A' 0))
          ((Var 'Y') (Var 'Y') ('B' 0) ('A' 0) (Var 'X'))
        )
        (
          (OR (not empty (Var 'X')))
        )
        (/* No index equations */)
      )
    )
    (
      2
      ('A' 1)
      ('A' 0) ('B' 0)
      (
        (
          AreEqual
          ((Var 'X') ('A' 0) ('B' 0) (Var 'Y'))
          ((Var 'Y') ('B' 0) ('A' 0) (Var 'X'))
        )
        (
          (OR (not empty (Var 'Y')))
        )
        (/* No index equations */)
      )
    )
    (
      3
      ('A' 1)
      ('A' 0) ('B' 0)
      (
        (
          AreEqual
          (('B' 0) (Var 'X') (Var 'Y') ('A' 0))
          ((Var 'X') ('B' 0) (Var 'Z') (Var 'Y'))
        )
        (/* No constraints */)
        (/* No index equations */)
      )
    );
}

/*
  <TestSet-BlockComp>
    == *(s.SeqNumber t.Const t.Index t.BlockConst t.Eq)
*/
TestSet-BlockComp {
  = (
      1
      ('A' 0) i1
      (
        (
          AreEqual
          ((Var 'X') ('A' 0) ('A' 0))
          (('B' 0)(Var 'Y'))
        )
        (/* No constraints */)
        (/* No conditions */)
      )
    );
}

Run-BlockComp {
  (1 e.Input)
    , <BlockComp e.Input> : {
      e.NewEqs
        , e.NewEqs
        : e.L1
          (
            (
              AreEqual
              (('A' 1))
              (('B' 0) ('A' 2))
            )
            (/* no constraints */)
            (
              (('A' 1) is (('A' 0) (i1 1) (const 2)))
              (('A' 2) is (('A' 0) (i2 1) (const 0)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          (
            (AreEqual
              (('A' 1))
              (('B' 0) ('A' 2) (Var 'Y') ('A' 3))
            )
            (
              (OR (not ('A' 0) starts (Var 'Y')))
              (OR (not empty (Var 'Y')))
              (OR (not ('A' 0) ends (Var 'Y')))
            )
            (
              (('A' 1) is (('A' 0) (i1 1) (const 2)))
              (('A' 2) is (('A' 0) (i2 1) (const 0)))
              (('A' 3) is (('A' 0) (i3 1) (const 0)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          (
            (AreEqual
              (('A' 1) (Var 'X') ('A' 2))
              (('B' 0) ('A' 3))
            )
            (
              (OR (not ('A' 0) starts (Var 'X')))
              (OR (not empty (Var 'X')))
              (OR (not ('A' 0) ends (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (i1 1) (const 0)))
              (('A' 2) is (('A' 0) (i2 1) (const 2)))
              (('A' 3) is (('A' 0) (i3 1) (const 0)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          (
            (AreEqual
              (('A' 1) (Var 'X') ('A' 2))
              (('B' 0) ('A' 3) (Var 'Y') ('A' 4))
            )
            (
              (OR (not ('A' 0) starts (Var 'X')))
              (OR (not empty (Var 'X')))
              (OR (not ('A' 0) ends (Var 'X')))
              (OR (not ('A' 0) starts (Var 'Y')))
              (OR (not empty (Var 'Y')))
              (OR (not ('A' 0) ends (Var 'Y')))
            )
            (
              (('A' 1) is (('A' 0) (i1 1) (const 0)))
              (('A' 2) is (('A' 0) (i2 1) (const 2)))
              (('A' 3) is (('A' 0) (i3 1) (const 0)))
              (('A' 4) is (('A' 0) (i4 1) (const 0)))
            )
          )
          e.R4
        = True;

      e.Other = False;
    };
}

RunPick {
  1 e.Eqs
    , <Pick 1 e.Eqs> : {
        (e.Eq) = True;
        e.Other = False;
      };

  2 e.Eqs
    , <Pick 2 e.Eqs> : {
        (e.Eq) = True;
        e.Other = False;
      };

  3 e.Eqs
    , <Pick 3 e.Eqs> : {
        NotMinimal = True;
        e.Other = False;
      };

  4 e.Eqs
    , <Pick 4 e.Eqs> : {
        Success = True;
        e.Other = False;
      };
}

RunSubstIndices {
  (1 e.Substs) t.EqData
    , <MapCompose (e.Substs) t.EqData> : {
        /* This unit test allows the implementation to choose freely
          whether to prune equal constants from left or from right. */
        (
          (AreEqual (/* No terms */) (e.W1 (Var 'X') e.W2))
          ((OR (not empty (Var 'X'))))
          ((('A' s.Ind) is (('A' 0) (i2 2) (const 2))))
        ), e.W1 e.W2 : ('A' s.Ind) = True;

        e.Z = False;
      };

  (2 e.Substs) t.EqData
    , <MapCompose (e.Substs) t.EqData> : {
        (
          (AreEqual ((Var 'Y')) ((Var 'X')))
          (/* EMPTY */)
          (/* EMPTY */) /* All the dependencies collapsed. */
        ) = True;
        
        e.Z = False;
      };

  (3 e.Substs) t.EqData
    , <MapCompose (e.Substs) t.EqData> : {
        (
          (
            AreEqual
            (('A' s.Ind) (Var 'Y')('A' s.Ind) (Var 'Y'))
            (('A' 2) (Var 'X'))
          )
          (/* EMPTY */)
          /* The implementation can preserve either ('A' 1)
             or ('A' 3) - no choice is forced. */
          (e.IndEq1 (('A' 2) is (('A' 0) (i2 5) (i3 3) (const 1))) e.IndEq2)
        ), e.IndEq1 e.IndEq2
          : (('A' s.Ind) is (('A' 0) (i2 6) (i3 3) (const 1))) = True;

        e.Z = False;
      };

  (4 e.Substs) t.EqData
    , <MapCompose (e.Substs) t.EqData> : {
        (
          /* The equal prefixes are pruned forward up to non-equal parts. */
          (AreEqual (('A' s.Ind) (Var 'Y')) ((Var 'Z') ('A' s.Ind)))
          (/* EMPTY */)
          ((('A' s.Ind) is (('A' 0) (i2 6) (i3 3) (const 1))))
        ) = True;

        e.Z = False;
      };
}

/*
  <RunPairComp (s.SeqNumber) (e.NewConst) (e.Const1) (e.Const2) (e.Eq)>
    == True
    == False
*/
RunPairComp {
  /* TODO: fix tests */
  (1 e.Input)
    , <PairComp e.Input> : {
      ('B' 1) (e.NewEqs)
        , e.NewEqs
        : e.L1
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y') ('A' 1))
              (('A' 0) (Var 'Y') ('A' 1) (Var 'Y') ('B' 0) ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          (
            (
              AreEqual
              ((Var 'X') ('B' 0) (Var 'Y') ('A' 1))
              ((Var 'Y') ('B' 0) (Var 'Y') ('B' 0) ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
              (OR (not ('A' 0) starts (Var 'Y')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              (('A' 0) (Var 'Y') ('A' 0) (Var 'Y') ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
              (OR (not ('B' 0) ends (Var 'Y')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          (
            (
              AreEqual
              ((Var 'X') ('B' 0) (Var 'Y') ('A' 0))
              ((Var 'Y') (Var 'Y') ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
              (OR (not empty (Var 'Y')))
              (OR (not ('B' 0) ends (Var 'Y')))
              (OR (not ('A' 0) starts (Var 'Y')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R4
        , e.L4 e.R4
        : e.L5
          (
            (
              AreEqual
              ((Var 'X') ('A' 1))
              (('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
            )
            (/* No Conditions */)
          )
          e.R5
        = True;
        
        e.Other = False;
    };
    
  (2 e.Input)
    , <PairComp e.Input> : {
      ('B' 1) (e.NewEqs)
        , e.NewEqs
        : e.L1
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'Y') ('A' 1) ('A' 1) (Var 'X'))
            )
            (/* No constraints */)
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'Y') ('A' 1) ('A' 0) (Var 'X'))
            )
            (
              (OR (not ('B' 0) starts (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y'))
              ((Var 'Y') ('B' 0) ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'Y')))
              (OR (not ('A' 0) ends (Var 'Y')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y'))
              ((Var 'Y') ('B' 0) ('A' 0) (Var 'X'))
            )
            (
              (OR (not empty (Var 'Y')))
              (OR (not ('A' 0) ends (Var 'Y')))
              (OR (not ('B' 0) starts (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R4
        = True;
        
        e.Other = False;
    };
    
  (3 e.Input)
    , <PairComp e.Input> : {
      ('B' 1) (e.NewEqs)
        , e.NewEqs
        : e.L1
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'X') ('A' 1) (Var 'Z') ('A' 1) (Var 'Y'))
            )
            (/* No constraints */)
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'X') ('A' 1) (Var 'Z') ('B' 0) (Var 'Y'))
            )
            (
              (OR (not ('A' 0) ends (Var 'Z')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 0) (Var 'Y') ('A' 0))
              ((Var 'X') ('A' 1) (Var 'Z') (Var 'Y'))
            )
            (
              (OR (not ('B' 0) starts (Var 'Y')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('B' 0) (Var 'Y') ('A' 0))
              ((Var 'X') ('B' 0) (Var 'Z') ('A' 1) (Var 'Y'))
            )
            (
              (OR (not ('A' 0) ends (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R4
        , e.L4 e.R4
        : e.L5
          (
            (
              AreEqual
              (('B' 0) (Var 'X') (Var 'Y') ('A' 0))
              ((Var 'X') ('B' 0) (Var 'Z') (Var 'Y'))
            )
            (
              (OR (not ('A' 0) ends (Var 'X')))
              (OR (not ('A' 0) ends (Var 'Z')) (not ('B' 0) starts (Var 'Y')))
            )
            (/* No index equations */)
          )
          e.R5
        = True;
        
      e.Other = False;
    };
}

/*
  <Pick s.Number e.Equations>
    == t.Equation
*/
Pick {
  1 ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions)) e.RestEquations
    , <SubtractSets
        (<GetUniqueValues Flat <MapCall Plain GetVars (e.LHS) (e.RHS)>>)
        (<GetNonEmptyVars e.Constraints>)
      >
    : (e.VarsForSubst)
    , <MapCall
        Revert
        (GenSubst (/* EMPTY */))
        <MapCall Plain FormTerm e.VarsForSubst>
      >
    : e.Substs
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.LHS) (e.RHS)
      >
    : {
      (e.Half) (e.Half) = Success;

      (e.NewLHS) (e.NewRHS)
        , <MapCall Plain GetConsts (e.NewLHS) (e.NewRHS)> : {
          /* No consts were found */ = NotMinimal;

          e.SomeConsts
            = ((AreEqual (e.NewLHS) (e.NewRHS)) (e.Constraints) (e.Conditions)); 
        };
    };

  s.Number t.Equation e.RestEquations = <Pick <Sub s.Number 1> e.RestEquations>;
}

/*
  <Subst (e.Substs) (e.Expr)>
    == (e.SubstExpr)
*/
Subst {
  (e.Substs) (e.Expr)
    , e.Substs : {
      t.Subst e.RestSubsts
        = <Subst (e.RestSubsts) (<Subst-Aux t.Subst e.Expr>)>;

      /* No substs */ = (e.Expr);
    };
}

Subst-Aux {
  t.Subst e.Expr
    , t.Subst : (assign (e.Old) (e.New))
    , e.Expr : {
      e.L e.Old e.R = e.L e.New <Subst-Aux t.Subst e.R>;

      /* Nothing to substitute. */
      e.Other = e.Other;
    };
}

/*
  <GenSubst (e.Old) (e.New)>
    == t.Subst
*/
GenSubst {
  (e.Old) (e.New) = (assign (e.Old) (e.New));
}

/*
  <GetNonEmptyVars e.Constraints>
    == e.NonEmptyVars
*/
GetNonEmptyVars {
  e.L (OR (not empty (Var s.X))) e.R = (Var s.X) <GetNonEmptyVars e.R>;

  /* No appropriate disjuncts left */
  e.Other = /* EMPTY */;
}

/*
  <GetVars (e.Elems)>
    == e.Vars
*/
GetVars {
  (e.L (Var s.X) e.R) = (Var s.X) <GetVars (e.R)>;

  (e.Other) = /* EMPTY */;
}

GetConsts {
  (t.Comp e.RestComps)
    , t.Comp : {
      (Var s.Name) = <GetConsts (e.RestComps)>; /* Ignore vars. */

      (s.Name s.Number) = t.Comp <GetConsts (e.RestComps)>;
      
      e.Other = <Prout 'GetConsts: Invalid component ' e.Other>;
    };

  (/* No more comps */) = /* EMPTY */;

  e.Other = <Prout 'GetConsts: Invalid input ' e.Other>;
}

/*
  <SubstIndex s.Index (e.Subst) (e.Eq)>
    == (e.SubstEq)
*/
SubstIndex {
  s.Index (e.Multiset)
  ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.IndexEqs))
    , <MapCall
        Curry
        (SubstToIndexEq (s.Index (e.Multiset)))
        e.IndexEqs
      >
    : e.SubstIndexEqs
    , <MapCompose
        ((TrimEquation Left) (TrimEquation Right))
        ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.SubstIndexEqs))
      >
    : ((AreEqual (e.TrimmedLHS) (e.TrimmedRHS)) e.Rest)
    , <MapCall
        Curry
        (
          CheckIndexEqToCollapse
          (
            <GetUniqueValues
              Flat
              <GetConsts (e.TrimmedLHS)> <GetConsts (e.TrimmedRHS)>
            >
          )
        )
        e.SubstIndexEqs
      >
    : e.NecessaryIndexEqs
    , <ReplaceRepeatedIndexEqs
        (e.NecessaryIndexEqs)
        (/* No substitutions at start */)
      > : (e.UniqueIndexEqs) (e.Substs)
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.TrimmedLHS) (e.TrimmedRHS)
      > : (e.SubstLHS) (e.SubstRHS)
    = ((AreEqual (e.SubstLHS) (e.SubstRHS)) (e.Constraints) (e.UniqueIndexEqs));
  
  e.Other = <Prout 'SubstIndex: Invalid input ' e.Other>;
}

/*
  <SubstToIndexEq (s.Index (e.Multiset)) (e.IndexEq)> == (e.SubstIndexEq)
*/
SubstToIndexEq {
  (s.Index (e.Multiset)) ((s.Name s.Number) is (e.RHS))
    = (
        (s.Name s.Number)
        is
        (<SumUpComps /* TODO: lexicographic sort */
          <MapCall Curry (SubstToComp (s.Index (e.Multiset))) e.RHS>
        >)
      );
    
  e.Other = <Prout 'SubstToIndexEq: Invalid input ' e.Other>;
}

/*
  <SubstToComp (s.Index (e.Multiset)) (e.Comp)> == (e.SubstComp)
*/
SubstToComp {
  (s.Index (e.Multiset)) (e.Comp)
    , e.Comp : {
      s.Index s.Number = <MapCall Curry (MulComp s.Number) e.Multiset>;

      s.AnotherIndex s.Number = (e.Comp);

      e.Other = <Prout 'SubstToComp: Invalid component ' e.Other>;
    };
    
  e.Other = <Prout 'SubstToComp: Invalid input ' e.Other>;
}

/*
  <MulComp s.Multiplier (e.Comp)> == (e.MulComp)
*/
MulComp {
  s.Multiplier (s.Index s.Number) = (s.Index <Mul s.Multiplier s.Number>);
  
  e.Other = <Prout 'MulComp: Invalid input ' e.Other>;
}

/*
  <SumUpComps e.Comps> == e.SummedUpComps
*/
SumUpComps {
  e.U1 (s.Index s.Number1) e.U2 (s.Index s.Number2) e.U3
    = e.U1 e.U2 (s.Index <Add s.Number1 s.Number2>) <SumUpComps e.U3>;
    
  e.SummedUpComps = e.SummedUpComps;
}

/*
  <TrimEquation s.Mode t.Equation>
    == t.TrimmedEquation
*/
TrimEquation {
  s.Mode t.Equation
    , Left Right : e.L s.Mode e.R /* verifying the mode */
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.IndexEqs))
    , <MapCall Curry (Take s.Mode) (e.LHS) (e.RHS)> : {
      /* Both equation parts are not empty */
      (t.Elem1 e.LHS1) (t.Elem2 e.RHS1)
        , <AreElementsEqual t.Elem1 t.Elem2 (e.IndexEqs)> : {
          True
            = <TrimEquation
                s.Mode
                ((AreEqual (e.LHS1) (e.RHS1)) (e.Constraints) (e.IndexEqs))
              >;

          False = t.Equation;
        };

      /* At least one part of the equation is empty */
      e.Other = t.Equation;
    };
  
  e.Other = <Prout 'TrimEquation: Invalid input ' e.Other>;
}

/*
  <AreElementsEqual (e.Comp1) (e.Comp2) (e.IndexEqs)>
    == True
    == False
*/
AreElementsEqual {
  (e.Comp1) (e.Comp2) (e.IndexEqs)
    , (e.Comp1) (e.Comp2) : {
      (s.Type s.Value) (s.Type s.Value) = True;

      (Var s.Value1) (Var s.Value2) = False;

      (s.Type s.Value1) (s.Type s.Value2)
        , <MapCall Curry (GetIndexEq (e.IndexEqs)) (e.Comp1) (e.Comp2)> : {
          ((e.Comp1) is (e.RHS)) ((e.Comp2) is (e.RHS)) = True;
              
          e.DifferentIndexEqs = False;
        };
        
      (s.Type1 s.Value1) (s.Type2 s.Value2) = False;

      e.Other = <Prout 'AreElementsEqual: Invalid components ' e.Other>;
    };

  e.Other = <Prout 'AreElementsEqual: Invalid input ' e.Other>;
}

/*
  <GetIndexEq (e.IndexEqs) (e.Comp)>
    == (e.IndexEq)
    == ε
*/
GetIndexEq {
  ((e.IndexEq) e.RestIndexEqs) (e.Comp)
    , e.IndexEq : {
      (e.Comp) is (e.RHS) = (e.IndexEq);

      e.AnotherIndexEq = <GetIndexEq (e.RestIndexEqs) (e.Comp)>;
    };

  /* Abnormal case */
  (/* No more index equations */) (e.Comp) = /* EMPTY */;
}

/*
  <CheckIndexEqToCollapse (e.Consts) (e.IndexEq)>
    == (e.IndexEq)
    == ε
*/
CheckIndexEqToCollapse {
  (e.U1 (e.Comp) e.U2) ((e.Comp) is (e.RHS)) = ((e.Comp) is (e.RHS));
    
  (e.Consts) (e.NotInvolvedIndexEq) = /* EMPTY */;

  e.Other = <Prout 'CheckIndexEqToCollapse: Invalid input ' e.Other>;
}

/*
  <ReplaceRepeatedIndexEqs (e.IndexEqs) (e.Substs)>
    == (e.ReplacedIndexEqs) (e.Substs)
*/
ReplaceRepeatedIndexEqs {
  (
    e.U1
    ((e.Comp1) is (e.RHS))
    e.U2
    ((e.Comp2) is (e.RHS))
    e.U3
  )
  (e.Substs) 
    = <ReplaceRepeatedIndexEqs
        (e.U1 ((e.Comp1) is (e.RHS)) e.U2 e.U3)
        (<GenSubst ((e.Comp2)) ((e.Comp1))> e.Substs)
      >;
      
  (e.UniqueIndexEqs) (e.Substs) = (e.UniqueIndexEqs) (e.Substs);
  
  e.Other = <Prout 'ReplaceRepeatedIndexEqs: Invalid input ' e.Other>;
}

/*
  <PairComp t.ReplacingConst t.Const1 t.Const2 t.Equation>
    == t.NewReplacingConst (e.Equations)
*/
PairComp {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    = <GetNewConst t.ReplacingConst>
      (
        <HandleEmptySubsts
          t.ReplacingConst t.Const1 t.Const2 t.Equation
        >
      );
}

/*
  If an essentially empty substitution is possible, recursively calls itself
  with an applied and not applied substitution equations. Otherwise, transfers
  control to the `HandleNonEmptySubsts` function.
  
  <HandleEmptySubst
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    /* Calling `GetEmptySubst` is quite expensive, so here's
       used `CallTill` not to make redundant calculations with `MapCall` */
    , <CallTill
        (/* EMPTY */)
        Curry
        (
          GetEmptySubst
          t.Const1 t.Const2 (e.Constraints)
        )
        (e.LHS) (e.RHS)
      >
    : {
      /* Found an essentially empty substitution */
      t.Subst
        = /* Calling with performed substitution */
          <HandleEmptySubsts 
            t.ReplacingConst t.Const1 t.Const2
            (
              (
                AreEqual
                <MapCall Curry (Subst (t.Subst)) (e.LHS) (e.RHS)>
              )
              (e.Constraints)
              (e.Conditions)
            )
          >
          /* Calling with not performed substitution */
          <HandleEmptySubsts
            t.ReplacingConst t.Const1 t.Const2
            (
              (AreEqual (e.LHS) (e.RHS))
              (e.Constraints (OR <GenSubstDenial t.Subst>))
              (e.Conditions)
            )
          >;
      
      /* No essentially empty substitution is found. */
      /* EMPTY */
        = <HandleNonEmptySubsts
            t.ReplacingConst t.Const1 t.Const2 t.Equation
          >;
    };
}

/*
  Returns any essentially empty substitution possible in the given equation
  half. If no such substitution is found, returns ε.
  
  <GetEmptySubst
    t.Const1 t.Const2 (e.Constraints) (e.EquationHalf)
  >
    == t.Subst
    == ε
*/
GetEmptySubst {
  t.Const1 t.Const2 (e.Constraints) (e.EquationHalf)
    /* Saving the result of frequently called functions */
    , <VarAlphabet> : e.Vars
    , <GetNonEmptyVars e.Constraints> : e.NonEmptyVars
    , e.EquationHalf : {
      e.L t.Const1 e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            (e.Vars)
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;
        
      e.L t.Const1 e.M (Var s.X) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;

      e.L (Var s.X) e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;

      e.L (Var s.X) e.M  (Var s.Y) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X) (Var s.Y))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;
        
      /* No essentially empty substitutions for this half of the equation */
      e.Other = /* EMPTY */;
    };
}

VarAlphabet {
  = <MapCall
      Plain
      GenVar
      <LatinCapitalLetters>
    >;
}

GenVar {
  s.Name = (Var s.Name);
}

/*
  Finds and applies essentially non-empty substitutions to the equation. 
  
  <HandleNonEmptySubsts
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleNonEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    , <GetNonEmptySubsts /* substitutions for the right half */
        t.Const1 t.Const2 (e.Constraints) (e.Conditions)
        <GetNonEmptySubsts /* substitutions for the left half */
          t.Const1 t.Const2 (e.Constraints) (e.Conditions)
          (/* No discovered elementary substitutions at start */)
          (/* No discovered composite substitutions at start */)
          (e.LHS)
        >
        (e.RHS)
      > : (e.ElementarySubsts) (e.CompositeSubsts)
    , <CartesianProductOfOptionSets
        <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
      >
    : (e.MultipliedOptions) /* what if no options initially? */
    , <MapCall
        Curry
        (ProcessOption (e.Conditions))
        e.MultipliedOptions
      > : {
      /* No implicit occurences. Applying empty option to the equation. */
      /* EMPTY */
        = <ApplyOption
            t.ReplacingConst t.Const1 t.Const2 t.Equation
            ((/* No substitutions */)(/* No constraints */))
          >;

      e.ProcessedOptions
        = <MapCall
            Curry
            (ApplyOption t.ReplacingConst t.Const1 t.Const2 t.Equation)
            e.ProcessedOptions
          >;
    };
}

/*
  Returns essentially non-empty substitutions for the given equation half.
  There are no impossible substitutions among returned.
  
  <GetNonEmptySubst
    t.Const1 t.Const2 (e.Constraints) (e.Conditions)
    (e.DiscoveredElementarySubsts) (e.DiscoveredCompositeSubsts) (e.Elems)
  >
    == e.Substs
*/
GetNonEmptySubsts {
  t.Const1 t.Const2 (e.Constraints) (e.Conditions)
  (e.ElementarySubsts) (e.CompositeSubsts) (e.Elems)
    , e.Elems : {
      (Var s.X) (Var s.Y) e.RestElems
        , <GenSubst ((Var s.X)) ((Var s.X) t.Const1)> : t.Subst1
        , <GenSubst ((Var s.Y)) (t.Const2 (Var s.Y))> : t.Subst2
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.Y) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts (t.Subst1 t.Subst2))
            ((Var s.Y) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet (t.Subst1 t.Subst2) (e.CompositeSubsts)> : {
            /* The substitution is already processed. */
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.ConstX ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.ConstX
                      (t.Const1 <GetLast t.Const1 (e.Conditions)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False
                        ,  e.L e.R : {
                          e.L1 (OR (not t.ConstY starts (Var s.Y))) e.R1
                            , <IsElemInSet
                                t.ConstY
                                (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                              > : {
                                /* The substitution is impossible. */
                                True = <UnwrapCalls t.SkipSubst>;

                                False = <UnwrapCalls t.AddSubst>;
                              };
                          
                          /* No constraint on the substitution. */
                          e.L e.R = <UnwrapCalls t.AddSubst>;
                        };
                    };

                /* No constraint on the first substitution. */
                e.L (OR (not t.ConstY starts (Var s.Y))) e.R
                  , <IsElemInSet
                      t.ConstY
                      (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;

                      False = <UnwrapCalls t.AddSubst>;
                    };

                /* No constraints on the substitutions. */
                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Const1 (Var s.X) e.RestElems
        , <GenSubst ((Var s.X)) (t.Const2 (Var s.X))> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.Const starts (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };
        
      (Var s.X) t.Const2 e.RestElems
        , <GenSubst ((Var s.X)) ((Var s.X) t.Const1)> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            (e.RestElems) /* can skip t.Const2 */
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            (e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.Const ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const1 <GetLast t.Const1 (e.Conditions)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Elem1 t.Elem2 e.RestElems
        = <GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            (t.Elem2 e.RestElems)
          >;

      e.OneOrNoTerm = (e.ElementarySubsts) (e.CompositeSubsts);
    };
}

/*
  Returns the First-elements of the constant.

  <GetFirst t.Const (e.Conditions)>
    == e.FirstElems
*/
GetFirst {
  t.Const (e.Conditions)
    , e.Conditions : {
      e.L (t.Const is (t.FirstElem e.Details) e.Elems) e.R
        = t.FirstElem <GetFirst t.FirstElem (e.L e.R)>;

      /* No condition for the constant. */
      e.Conditions = /* EMTPY */;
    };
}

/*
  Returns the Last-elements of the constant.

  <GetLast t.Const (e.Conditions)>
    == e.LastElems
*/
GetLast {
  t.Const (e.Conditions)
    , e.Conditions : {
      e.L (t.Const is e.Elems (t.LastElem e.Details)) e.R
        = t.LastElem <GetLast t.LastElem (e.L e.R)>;
      
      /* No condition for the constant. */
      e.Conditions = /* EMPTY */;
    };
}

/*
  <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
    == e.OptionSets
*/
GenOptionSets {
  (e.ElementarySubsts) (e.CompositeSubsts)
    , <GetUniqueValues
        Flat
        <MapCall
          Revert
          (GetSpecialSubsts (e.ElementarySubsts))
          e.CompositeSubsts
        >
      >
    : e.SpecialSubsts
    , <SubtractSets (e.ElementarySubsts) (e.SpecialSubsts)>
    : (e.UnprocessedElementarySubsts)
    = <MapCall
        Revert
        (GenCompositeOptionSet (e.SpecialSubsts))
        e.CompositeSubsts
      >
      <MapCall
        Plain
        GenElementaryOptionSet
        e.UnprocessedElementarySubsts
      >;
}

/*
  For the equation, we call an essential elementary substitution "special"
  if it is present in some essential composite substitution.

  Returns special substitutions of the given composite substitution.
  
  <GetSpecialSubsts t.CompositeSubst (e.ElementarySubsts)>
    == e.SpecialSubsts
*/
GetSpecialSubsts {
  (t.Subst1 t.Subst2) (e.ElementarySubsts)
    , e.ElementarySubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is special too. */
          e.L1 t.Subst2 e.R1 = t.Subst1 t.Subst2;

          /* Only the first substitution is special. */
          e.Other = t.Subst1;
        };

      /* Only the second substitution is special. */
      e.L t.Subst2 e.R = t.Subst2;

      /* None of the substitutions are special. */
      e.Other = /* EMPTY */;
    };
}

/*
  We will call an option set composite if it is obtained from a composite
  substitution. 
  
  <GenCompositeOptionSet t.CompositeSubst (e.SpecialSubsts)>
    == e.OptionSet
*/
GenCompositeOptionSet {
  (t.Subst1 t.Subst2) (e.SpecialSubsts)
    , e.SpecialSubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is special too. */
          e.L1 t.Subst2 e.R1
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
                (
                  (t.Subst2)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
              );

          /* Only the first substitution is special. */
          e.Other
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                  )
                )
              );
        };

      /* Only the second substitution is special. */
      e.L t.Subst2 e.R
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (t.Subst2)
              (
                (OR <GenSubstDenial t.Subst1>)
              )
            )
            (
              (/* No substitutions */)
              (
                (OR <GenSubstDenial t.Subst2>)
              )
            )
          );

      /* None of the substitutions are special. */     
      e.Other
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (/* No substitutions */)
              (
                (
                  OR
                  <GenSubstDenial t.Subst1>
                  <GenSubstDenial t.Subst2>
                )
              )
            )
          );
    };
}

/*
  <GenSubstDenial t.ElementarySubst>
    == t.Restriction
*/
GenSubstDenial {
  (assign (t.Var) (e.NewValue))
    , e.NewValue : {
      t.Var t.Const = (not t.Const ends t.Var);

      t.Const t.Var = (not t.Const starts t.Var);

      /* EMPTY */ = (not empty t.Var);
    };
}

/*
  We will call an option set elementary if it is obtained from an elementary
  substitution. 
  
  <GenElementaryOptionSet t.ElementarySubst>
    == e.OptionSet
*/
GenElementaryOptionSet {
  t.Subst
    = (
        (
          (t.Subst)
          (/* No constraints */)
        )
        (
          (/* No substitutions */)
          (
            (OR <GenSubstDenial t.Subst>)
          )
        )
      );
}

/*
  <CartesianProductOfOptionSets e.OptionSets>
    == (e.MultipliedOptions)
*/
CartesianProductOfOptionSets {
  (e.Set1) (e.Set2) e.RestSets
    = <CartesianProductOfOptionSets 
        <CartesianProduct Overlap (e.Set1) (e.Set2)> e.RestSets
      >;

  (e.Set) = (e.Set);

  /* No sets */ = (/* EMPTY */);
}

/*
  Cartesian product of two arbitary sets with custom pair processing function.
  
  <CartesianProduct s.ProcessingFunction (e.Set1) (e.Set2)>
    == (e.MultipliedElements)
*/
CartesianProduct {
  s.ProcessingFunction (e.Set1) (e.Set2)
    = (<MapCall
        Curry
        (CartesianProduct-Aux s.ProcessingFunction (e.Set2))
        e.Set1
      >);
}

CartesianProduct-Aux {
  s.ProcessingFunction (e.Set) t.Elem
    = <MapCall Curry (s.ProcessingFunction t.Elem) e.Set>;
}

/*
  Removes duplicates, redundant constraints and checks the option for
  consistency.
  
  <ProcessOption (e.Conditions) t.Option>
    == t.ProcessedOption
    == ε
*/
ProcessOption {
  (e.Conditions) ((e.Substs) (e.Constraints))
    , <MapCall
        Curry
        (GetUniqueValues Wrap)
        (e.Substs) (e.Constraints)
      > : (e.UniqueSubsts) (e.UniqueConstraints)
    , <RemoveTrivialConstraints
        (e.UniqueConstraints)
        (e.Conditions)
      > : e.NecessaryConstraints
    = <FixOptionConsistency
        ((e.UniqueSubsts) (e.NecessaryConstraints))
        (/* No checked substitutions at start */)
        (e.Conditions)
      >;
}

/*
  Removes trivially performed non-trivial disjuncts.
  
  <RemoveTrivialConstraints (e.Constraints) (e.Conditions)>
    == e.NecessaryConstraints
*/
RemoveTrivialConstraints {
  (e.Constraints) (e.Conditions)
    , e.Constraints : {
      e.L (OR (not t.Const1 ends t.VarX) (not t.Const2 starts t.VarY)) e.R
        , e.L e.R : {
          e.L1 (OR (not t.ConstX ends t.VarX)) e.R2
            , <IsElemInSet t.ConstX
                (t.Const1 <GetLast t.Const1 (e.Conditions)>)
              > : True /* found stronger restriction */
            = e.L <RemoveTrivialConstraints (e.R) (e.Conditions)>;
                
          e.L1 (OR (not t.ConstY starts t.VarY)) e.R2
            , <IsElemInSet
                t.ConstY
                (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
              > : True
            = e.L <RemoveTrivialConstraints (e.R) (e.Conditions)>;

          e.L e.R /* cannot say whether the disjunct is redundant or not */
            = e.L (OR (not t.Const1 ends t.VarX) (not t.Const2 starts t.VarY))
              <RemoveTrivialConstraints (e.R) (e.Conditions)>;
        };
        
      e.TrivialDisjuncts = e.TrivialDisjuncts;
    };
}

/*
  Checks an option for consistency and fixes avoidable contradictions
  whenever necessary. If an unavoidable contradiction is found, returns ε.
  Otherwise, returns the processed option.
  
  <FixOptionConsistency t.Option (e.CheckedSubsts) (e.Conditions)>
    == t.FixedOption
    == ε
*/
FixOptionConsistency {
  ((e.UncheckedSubsts) (e.Constraints)) (e.CheckedSubsts) (e.Conditions)
    , e.UncheckedSubsts : {
      (assign (t.Var) (t.Var t.Const)) e.RestSubsts /* suffix substitution */
      , e.Constraints : {
        e.L (OR (not t.RestrConst ends t.Var) e.AnotherRestr) e.R
          , <IsElemInSet
              t.RestrConst
              (t.Const <GetLast t.Const (e.Conditions)>)
            > : True
          , e.AnotherRestr : {
            /* EMPTY */ = /* EMPTY */; /* unavoidable contradiction */

            t.Restr /* force another restriction to be executed */
              = <FixOptionConsistency
                  ((e.UncheckedSubsts) (e.L (OR t.Restr) e.R))
                  (e.CheckedSubsts) (e.Conditions)
                >;
          };
        
        /* No constraints on the substitution. */
        e.CheckedConstraints
          = <FixOptionConsistency
              ((e.RestSubsts) (e.CheckedConstraints))
              (e.CheckedSubsts (assign (t.Var) (t.Var t.Const)))
              (e.Conditions)
            >;
      };

      (assign (t.Var) (t.Const t.Var)) e.RestSubsts /* prefix substitution */
        , e.Constraints : {
          e.L (OR e.AnotherRestr (not t.RestrConst starts t.Var)) e.R
            , <IsElemInSet
                t.RestrConst
                (t.Const <GetFirst t.Const (e.Conditions)>)
              > : True
            , e.AnotherRestr : {
              /* EMPTY */ = /* EMPTY */;

              t.Restr
                = <FixOptionConsistency
                    ((e.UncheckedSubsts) (e.L (OR t.Restr) e.R))
                    (e.CheckedSubsts) (e.Conditions)
                  >;
            };

          e.CheckedConstraints
            = <FixOptionConsistency
                ((e.RestSubsts) (e.CheckedConstraints))
                (e.CheckedSubsts (assign (t.Var) (t.Const t.Var)))
                (e.Conditions)
              >;
        };
        
      /* All the substitutions are checked. */
      /* EMPTY */ = ((e.CheckedSubsts) (e.Constraints));
    };
}

/*
  Applies option substitutions to the equation (also adds corresponding index
  equation) and appends the option constraints to the equation constraints.
  Thereafter trimmes this equation, removes redundant elements and modifies
  constraints.
  
  <ApplyOption t.ReplacingConst t.Const1 t.Const2 t.Equation t.Option>
    == t.NewEquation
*/
ApplyOption {
  t.ReplacingConst t.Const1 t.Const2
  ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
  ((e.Substs) (e.NewConstraints))
    , <MapCall /* replacing the pairs with the new const */
        Curry
        (Subst (<GenSubst (t.Const1 t.Const2) (t.ReplacingConst)>))
        <MapCall /* applying the option substitutions */
          Curry
          (Subst (e.Substs))
          (e.LHS) (e.RHS)
        >
      > : (e.SubstLHS) (e.SubstRHS)
    , <MapCompose
        ((TrimEquation Left) (TrimEquation Right))
        ((AreEqual (e.SubstLHS) (e.SubstRHS)) (e.Constraints) (e.Conditions))
      > : ((AreEqual (e.TrimmedLHS) (e.TrimmedRHS)) e.Rest)
    , <GetUniqueValues
        Flat
        <MapCall Plain GetConsts (e.TrimmedLHS) (e.TrimmedRHS)>
      >: e.EqConsts
    , <RemoveRedundantConditions
        (e.EqConsts)
        (
          e.Conditions
          (t.ReplacingConst is (t.Const1 (const 1)) (t.Const2 (const 1)))
        )
        (/* EMPTY */)
      > : e.NecessaryConditions 
    , <RemoveRedundantRestrictions
        (e.EqConsts) (e.NecessaryConditions) (e.Constraints) (/* EMPTY */)
      > : e.NecessaryConstraints
    , <ModifyRestrictions
        (e.Substs) (e.NecessaryConstraints e.NewConstraints)
        (e.NecessaryConditions)
      > : e.ModifiedConstraints
    =
      (
        (AreEqual (e.TrimmedLHS) (e.TrimmedRHS))
        (e.ModifiedConstraints) (e.NecessaryConditions)
      );
}

/*
  TODO: fix the cycling

  Modifies constraints taking into account the substitutions.
  
  <ModifyRestrictions (e.Substs) (e.Constraints) (e.Conditions)>
    == e.ModifiedConstraints
*/
ModifyRestrictions {
  (e.Substs) (e.Constraints) (e.Conditions)
    , e.Substs : {
      (assign (t.Var) (t.Const t.Var)) e.RestSubsts
        , e.Constraints : { /* the order of the rules is important here */
          e.L (OR (not empty t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;

          /* Thanks to the GetNonEmptySubsts the t.PrefixConst is definitely
             not in the First(t.Const) set. */
          e.L (OR (not t.PrefixConst starts t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;

          e.L (OR t.SuffixRestr (not t.PrefixConst starts t.Var)) e.R
            , <IsElemInSet
                t.PrefixConst
                (<GetFirst t.Const (e.Conditions)>)
              > : {
              True /* forcing the suffix restriction to be executed */
                = <ModifyRestrictions
                    (e.RestSubsts) /* pay attention that we're moving on */
                    (e.L (OR t.SuffixRestr) e.R) (e.Conditions)
                  >;

              False /* cannot say anything definite, moving on */
                = <ModifyRestrictions
                    (e.RestSubsts) (e.Constraints) (e.Conditions)
                  >;
            };

          e.Other /* moving on */
            = <ModifyRestrictions
                (e.RestSubsts) (e.Constraints) (e.Conditions)
              >;
        };
      
      (assign (t.Var) (t.Var t.Const)) e.RestSubsts
        , e.Constraints : {
          e.L (OR (not empty t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;
            
          e.L (OR (not t.SuffixConst ends t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;

          e.L (OR (not t.SuffixConst ends t.Var) t.PrefixRestr) e.R
            , <IsElemInSet
                t.SuffixConst
                (<GetLast t.Const (e.Conditions)>)
              > : {
              True
                = <ModifyRestrictions
                    (e.RestSubsts) (e.L (OR t.PrefixRestr) e.R) (e.Conditions)
                  >;

              False
                = <ModifyRestrictions
                    (e.RestSubsts) (e.Constraints) (e.Conditions)
                  >;
            };

          e.Other
            = <ModifyRestrictions
                (e.RestSubsts) (e.Constraints) (e.Conditions)
              >;
        };
        
      /* EMPTY */ = e.Constraints;
    };
}

/*
  <RemoveRedundantRestrictions
    (e.EqConsts) (e.Conditions) (e.UncheckedConstraints) (e.CheckedConstraints)
  >
    == e.CheckedConstraints
*/
RemoveRedundantRestrictions {
  (e.EqConsts) (e.Conditions) (e.UncheckedConstraints) (e.CheckedConstraints)
    , e.UncheckedConstraints : {
      t.Constraint e.RestConstraints
        , t.Constraint : {
          /* Skipping constraints on emptiness. */
          (OR (not empty t.Var))
            = <RemoveRedundantRestrictions
                (e.EqConsts) (e.Conditions) (e.RestConstraints)
                (e.CheckedConstraints t.Constraint)
              >;
              
          /* Handling prefix (suffix) restrictions */ 
          (OR t.Restr1 e.AnotherRestr)
            , <IsRestrictionRedundant
                t.Restr1 (e.EqConsts) (e.Conditions)
              > : {
              True
                , e.AnotherRestr : {
                  /* EMPTY */ /* removing the disjunct */
                    = <RemoveRedundantRestrictions
                        (e.EqConsts) (e.Conditions) (e.RestConstraints)
                        (e.CheckedConstraints)
                      >;

                  t.Restr2
                    , <IsRestrictionRedundant
                        t.Restr2 (e.EqConsts) (e.Conditions)
                      > : {
                      True /* removing the disjunct */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conditions) (e.RestConstraints)
                            (e.CheckedConstraints)
                          >;
                      
                      False /* removing the first restriction */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conditions) (e.RestConstraints)
                            (e.CheckedConstraints (OR t.Restr2))
                          >;
                    };
                };

              False
                , e.AnotherRestr : {
                  /* EMPTY */
                    /* Saving the constraint */
                    = <RemoveRedundantRestrictions
                        (e.EqConsts) (e.Conditions) (e.RestConstraints)
                        (e.CheckedConstraints t.Constraint)
                      >;

                  t.Restr2
                    , <IsRestrictionRedundant
                        t.Restr2 (e.EqConsts) (e.Conditions)
                      > : {
                      True
                        /* Removing the second restriction. */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conditions) (e.RestConstraints)
                            (e.CheckedConstraints (OR t.Restr1))
                          >;

                      False
                        /* Saving the constraint */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conditions) (e.RestConstraints)
                            (e.CheckedConstraints t.Constraint)
                          >;
                    };
                };
            };
        
        };
        
      /* EMPTY */ = e.CheckedConstraints;
    };
}

/*
  Accepts only the prefix and suffix restrictions.

  <IsRestrictionRedundant t.Restr (e.EqConsts) (e.Conditions)>
    == True
    == False
*/
IsRestrictionRedundant {
  /* s.Action ::= starts | ends */
  (not t.Const s.Action t.Var) (e.EqConsts) (e.Conditions)
    , <IsElemInSet t.Const (e.EqConsts)> : {
      /* The constant is used in the equation. */
      True = False;
      
      False
        , e.Conditions : {
          /* At least one condition has the constant in the right half. */
          e.L (t.DefConst is e.L1 (t.Const e.Details) e.R1) e.R = False;
            
          /* The restriction is redundant. */
          e.Other = True; 
        };
    };
}

/*
  An index equation (condition) is redundant if:
  - a constant in its left half is missing from the equation;
  - all constants in its right half are missing from the equation and they
    are not left halfs of some index equations.

  <RemoveRedundantConditions
    (e.EqConsts) (e.UncheckedConditions) (e.CheckedConditions)
  >
    == e.CheckedConditions
*/
RemoveRedundantConditions {
  (e.EqConsts) (e.UncheckedConditions) (e.CheckedConditions)
    , e.UncheckedConditions : {
      t.Condition e.RestConditions
        , t.Condition : (t.DefConst is e.Elems)
        , <IsElemInSet t.DefConst (e.EqConsts)> : {
          False
            = <RemoveRedundantConditions
                (e.EqConsts) (e.RestConditions) (e.CheckedConditions)
              >;
              
          True
            , <GetConditionConsts t.Condition> : e.ConditionConsts
            , <IntersectSets (e.EqConsts) (e.ConditionConsts)> : {
                /* None of the condition constants are in the equation. */
                /* EMPTY */
                  , <CallTill
                      (/* EMPTY */)
                      Revert
                      (GetCondition (e.UncheckedConditions e.CheckedConditions))
                      e.ConditionConsts
                    > : {
                      /* EMPTY */
                        = <RemoveRedundantConditions
                            (e.EqConsts) (e.RestConditions)
                            (e.CheckedConditions)
                          >;

                      e.SomeConditions
                        = <RemoveRedundantConditions
                            (e.EqConsts) (e.RestConditions)
                            (e.CheckedConditions t.Condition)
                          >;
                  };

                e.SomeConsts
                  = <RemoveRedundantConditions
                      (e.EqConsts) (e.RestConditions)
                      (e.CheckedConditions t.Condition)
                    >;
            };
        };
        
      /* EMPTY */ = e.CheckedConditions;
    };
}

/*
  TODO: replace GetIndexEq with GetCondition.

  Returns a condition for t.Const or ε, if the condition isn't found.
  
  <GetCondition t.Const (e.Conditions)>
    == t.Condition
    == ε
*/
GetCondition {
  t.Const (e.Conditions)
    , e.Conditions : {
      e.L (t.Const is e.Elems) e.R = (t.Const is e.Elems);

      e.Other = /* EMPTY */;
    };
}

/*
  Returns constants in the right half of the condition.

  <GetConditionConsts t.Condition>
    == e.ConditionConsts
*/
GetConditionConsts {
  (t.DefConst is e.Elems)
    , e.Elems : {
      (t.Const e.Details) e.RestElems
        = t.Const <GetConditionConsts (t.DefConst is e.RestElems)>;
      
      /* No elements (abnormal on the first call) */
      /* EMPTY */ = /* EMPTY */;
    };
}

/*
  <IntersectSets (e.Set1) (e.Set2)>
    == e.Intersection
*/
IntersectSets {
  (e.L1 t.Elem e.R1) (e.L2 t.Elem e.R2)
    = t.Elem <IntersectSets (e.L1 e.R1) (e.L2 e.R2)>;

  /* No common elements */
  (e.Set1) (e.Set2) = /* EMPTY */;
}

/*
  <BlockComp t.BlockConst s.Index t.Eq>
    == e.NewEqs
*/
BlockComp {
  t.BlockConst s.Index t.Eq
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    , <GetUniqueValues
        Flat
        <MapCall Plain GetVars (e.LHS) (e.RHS)>
      > : e.EqVars
    , <MapCall
        Curry
        (GenBlockOptionSets (e.Constraints) (e.Conditions) t.BlockConst)
        e.EqVars
      > : e.OptionSets
    , <CartesianProductOfOptionSets e.OptionSets> : (e.MultipliedOptions)
    , <MapCall
        Curry
        (ApplyBlockOption t.BlockConst s.Index t.Eq)
        e.MultipliedOptions
      > : e.Eqs
    = e.Eqs; /* dummy output */
}

/*
  <ApplyBlockOption t.Const s.Index t.Eq t.BlockOption>
    == e.Eq
*/
ApplyBlockOption {
  t.BlockConst s.Index t.Eq t.Option
    , t.BlockConst : (s.Letter s.Number)
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    , t.Option : ((e.Substs) (e.AddedConstraints) (e.ExcludedConstraints))
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.LHS) (e.RHS)
      > : (e.SubstLHS) (e.SubstRHS)
    , <MapCall
        Curry
        (JoinBlocks t.BlockConst)
        (e.SubstLHS) (e.SubstRHS)
      > : (e.JoinedLHS) (e.JoinedRHS)
    , <BuildConditions
        t.BlockConst (s.Letter <Add s.Number 1>) s.Index (e.Conditions)
        (/* no processed elements at start */) (e.JoinedLHS)
      > : t.SomeConst s.SomeIndex (e.UpdatedConditionsForLHS) (e.UpdatedLHS)
    , <BuildConditions
        t.BlockConst t.SomeConst s.SomeIndex (e.UpdatedConditionsForLHS)
        (/* no processed elements at start */) (e.JoinedRHS)
      > : t.NewConst s.NewIndex (e.UpdatedConditions) (e.UpdatedRHS)
    = (
        (AreEqual (e.UpdatedLHS) (e.UpdatedRHS))
        <SubtractSets
          (e.Constraints e.AddedConstraints) (e.ExcludedConstraints)
        >
        (e.UpdatedConditions)
      );
}

/*
  TODO: придумать название получше...

  <BuildConditions
    t.BlockConst t.Const s.Index (e.Conditions) (e.ProcessedElems) (e.Elems)
  >
    == t.NewConst s.NewIndex (e.UpdatedConditions) (e.UpdatedElems)
*/
BuildConditions {
  t.BlockConst t.Const s.Index (e.Conditions) (e.ProcessedElems) (e.Elems)
    , t.Const : (s.Letter s.Number)
    , e.Elems : {
      e.L (t.BlockConst e.Indices t.Summand) e.R
        , <NameIndices
            s.Index (e.Indices) (/* no named indices at start */)
          > : s.NewIndex (e.NamedIndices)
        = <BuildConditions
            t.BlockConst (s.Letter <Add s.Number 1>) s.NewIndex
            (
              e.Conditions
              (
                t.Const is
                (
                  t.BlockConst <MapCall Revert (FormPair 1) e.NamedIndices>
                  t.Summand
                )
              )
            )
            (e.ProcessedElems e.L t.Const) (e.R)
          >;
          
      e.Other = t.Const s.Index (e.Conditions) (e.ProcessedElems e.Elems);
    };
}

/*
  <NameIndices s.Index (e.NamelessIndices) (e.NamedIndices)>
    == s.NewIndex (e.NamedIndices)
*/
NameIndices {
  s.Index (e.NamelessIndices) (e.NamedIndices)
    , e.NamelessIndices : {
      Index e.RestIndices
        = <NameIndices
            <GetNewIndex s.Index> (e.RestIndices) (e.NamedIndices s.Index)
          >;

      /* No nameless indices */ = s.Index (e.NamedIndices);
    };
}

/*
  Принимает блочную константу и часть уравнения и сжимает извлечённые блоки
  (а также явные длины >= 2).
  
  <JoinBlocks t.Const (e.Elems)>
    == (e.)
*/
JoinBlocks {
  t.Const (e.Elems)
    , e.Elems : {
      e.L t.Const (t.Const e.Inds (const s.Num)) e.R
        = <JoinBlocks
            t.Const
            (e.L (t.Const e.Inds (const <Add s.Num 1>)) e.R)
          >;
          
      e.L (t.Const e.Inds (const s.Num)) t.Const e.R
        = <JoinBlocks
            t.Const
            (e.L (t.Const e.Inds (const <Add s.Num 1>)) e.R)
          >;
          
      e.L (t.Const e.Inds1 (const s.Num1)) (t.Const e.Inds2 (const s.Num2)) e.R
        = <JoinBlocks
            t.Const
            (e.L (t.Const e.Inds1 e.Inds2 (const <Add s.Num1 s.Num2>)) e.R)
          >;
      
      e.L t.Const t.Const e.R
        = <JoinBlocks t.Const (e.L (t.Const (const 2)) e.R)>;

      e.Other = (e.Elems);
    };
}

/*
  <GenBlockOptionSets (e.Constraints) (e.Conditions) t.BlockConst t.Var>
    == e.OptionSets
*/
GenBlockOptionSets {
  (e.Constraints) (e.Conditions) t.BlockConst t.Var
    , <SelectConstraints (e.Constraints) Prefix t.Var> : e.PrefixConstraints
    , <CallTill
        (False) Curry (IsDependentConstraint (e.Conditions) t.BlockConst)
        e.PrefixConstraints
      > : s.HasDependentPrefixConstraints
    , <SelectConstraints (e.Constraints) Suffix t.Var> : e.SuffixConstraints
    , <CallTill
        (False) Curry (IsDependentConstraint (e.Conditions) t.BlockConst)
        e.SuffixConstraints
      > : s.HasDependentSuffixConstraints
    , (t.BlockConst Index (const 0)) : t.Block
    , (t.BlockConst Index (const 1)) : t.NonEmptyBlock
    , <SelectConstraints (e.Constraints) Empty t.Var> : {
      /* EMPTY */
        , <IsEmpty e.PrefixConstraints> : {
          True
            , <IsEmpty e.SuffixConstraints> : {
              /* no constraints */
              True
                = (
                    (
                      (<GenSubst (t.Var) (t.Block)>)
                      (/* no added constraints */)
                      (/* no excluded constraints */)
                    )
                    (
                      (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                      (
                        <GenPrefixConstraint t.Var t.BlockConst>
                        <GenEmptyConstraint t.Var>
                        <GenSuffixConstraint t.Var t.BlockConst>
                      )
                      (/* no excluded constraints */)
                    )
                  );

              False
                , s.HasDependentSuffixConstraints : {
                  /* dependent suffix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (/* empty */)>)
                          (/* no added constraints */)
                          (e.SuffixConstraints)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                          )
                          (/* no excluded constraints */)
                        )
                      );

                  /* independent suffix constraints */
                  False
                    = (
                        (
                          (<GenSubst (t.Var) (t.Block)>)
                          (/* no added constraints */)
                          (e.SuffixConstraints)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (e.SuffixConstraints)
                        )
                      );
                };
            };
          
          False
            , s.HasDependentPrefixConstraints : {
              True
                , <IsEmpty e.SuffixConstraints> : {
                  /* dependent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (/* empty */)>)
                          (/* no added constraints */)
                          (e.PrefixConstraints)
                        )
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                      );
                  
                  False
                    , s.HasDependentSuffixConstraints : {
                      /* dependent both prefix and suffix constraints */
                      True
                        = (
                            (
                              (<GenSubst (t.Var) (/* empty */)>)
                              (/* no added constraints */)
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                            (
                              (/* no substitutions */) 
                              (<GenEmptyConstraint t.Var>)
                              (/* no excluded constraints */)
                            )
                          );
                          
                      /* dependent prefix, independent suffix constraints */
                      False
                        = (
                            (
                              (<GenSubst (t.Var) (/* empty */)>)
                              (/* no added constraints */)
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                            (
                              (/* no substitutions */)
                              (
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>)
                              (
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.SuffixConstraints)
                            )
                          );
                    };
                };

              False
                , <IsEmpty e.SuffixConstraints> : {
                  /* independent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.Block)>)
                          (/* no added constraints */)
                          (e.PrefixConstraints)
                        )
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (e.PrefixConstraints)
                        )
                      );
                      
                  False
                    , s.HasDependentSuffixConstraints : {
                      /* independent prefix, dependent suffix constraints */
                      True
                        = (
                            (
                              (<GenSubst (t.Var) (/* empty */)>)
                              (/* no added constraints */)
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                            (
                              (/* no substitutions */)
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>)
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                              )
                              (e.PrefixConstraints)
                            )
                          );

                      /* independent both prefix and suffix constraints */
                      False
                        = (
                            (
                              (<GenSubst (t.Var) (t.Block)>)
                              (/* no added constraints */)
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                            (
                              (/* no substitutions */) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.SuffixConstraints)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.PrefixConstraints)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var t.Block)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                          );
                    };
                };
            };
        };
      
      t.EmptyConstraint
        , <IsEmpty e.PrefixConstraints> : {
          True
            , <IsEmpty e.SuffixConstraints> : {
              /* no other constraints */
              True
                = (
                    (
                      (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                      (/* no added constraints */)
                      (t.EmptyConstraint)
                    )
                    (
                      (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                      (
                        <GenPrefixConstraint t.Var t.BlockConst>
                        <GenSuffixConstraint t.Var t.BlockConst>
                      )
                      (/* no excluded constraints */)
                    )
                  );

              False
                , s.HasDependentSuffixConstraints : {
                  /* dependent suffix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (<GenPrefixConstraint t.Var t.BlockConst>)
                          (/* no excluded constraints */)
                        )
                      );

                  /* independent suffix constraints */
                  False
                    = (
                        (
                          (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                          (/* no added constraints */)
                          (e.SuffixConstraints t.EmptyConstraint)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (e.SuffixConstraints)
                        )
                      );
                };
            };
          
          False
            , s.HasDependentPrefixConstraints : {
              True
                , <IsEmpty e.SuffixConstraints> : {
                  /* dependent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                      );
                  
                  False
                    , s.HasDependentSuffixConstraints : {
                      /* dependent both prefix and suffix constraints */
                      True
                        = (
                            (
                              (/* no substitutions */) 
                              (/* no added constraints */)
                              (/* no excluded constraints */)
                            )
                          );
                          
                      /* dependent prefix, independent suffix constraints */
                      False
                        = (
                            (
                              (/* no substitutions */)
                              (<GenSuffixConstraint t.Var t.BlockConst>)
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>)
                              (<GenSuffixConstraint t.Var t.BlockConst>)
                              (e.SuffixConstraints)
                            )
                          );
                    };
                };

              False
                , <IsEmpty e.SuffixConstraints> : {
                  /* independent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                          (/* no added constraints */)
                          (e.PrefixConstraints t.EmptyConstraint)
                        )
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (e.PrefixConstraints)
                        )
                      );
                      
                  False
                    , s.HasDependentSuffixConstraints : {
                      /* independent prefix, dependent suffix constraints */
                      True
                        = (
                            (
                              (/* no substitutions */)
                              (<GenPrefixConstraint t.Var t.BlockConst>)
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>)
                              (<GenPrefixConstraint t.Var t.BlockConst>)
                              (e.PrefixConstraints)
                            )
                          );

                      /* independent both prefix and suffix constraints */
                      False
                        = (
                            (
                              (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                              (/* no added constraints */)
                              (
                                e.PrefixConstraints e.SuffixConstraints
                                t.EmptyConstraint
                              )
                            )
                            (
                              (/* no substitutions */) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.SuffixConstraints)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.PrefixConstraints)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var t.Block)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                          );
                    };
                };
            };
        };
    };
}

/*
  Относительно данной константы A будем называть рестрикцию X != BX зависимой,
  если B принадлежит множеству First(A), и независимой в противном случае.
  
  <IsDependentConstraint (e.Conditions) t.Const t.Constraint>
    == True
    == False
*/
IsDependentConstraint {
  (e.Conditions) t.Const t.Constraint
    , t.Constraint : {
      (OR (not t.PrefixConst starts t.Var))
        = <IsElemInSet
            t.PrefixConst
            (t.Const <GetFirst t.Const (e.Conditions)>)
          >;

      (OR (not t.SuffixConst ends t.Var))
        = <IsElemInSet
            t.SuffixConst
            (t.Const <GetLast t.Const (e.Conditions)>)
          >;
    };
}

SelectConstraints {
  (e.Constraints) s.Mode t.Var
    , s.Mode : {
      Prefix
        , e.Constraints : {
          e.L (OR (not t.PrefixConst starts t.Var)) e.R
            = (OR (not t.PrefixConst starts t.Var))
              <SelectConstraints (e.R) s.Mode t.Var>;

          e.Other = /* EMPTY */;
        };
      
      Suffix
        , e.Constraints : {
          e.L (OR (not t.SuffixConst ends t.Var)) e.R
            = (OR (not t.SuffixConst ends t.Var))
              <SelectConstraints (e.R) s.Mode t.Var>;

          e.Other = /* EMPTY */;
        };

      Empty
        , e.Constraints : {
          e.L (OR (not empty t.Var)) e.R = (OR (not empty t.Var));
        
          e.Other = /* EMPTY */;
        };
    };
}

/*
  <GenPrefixConstraint t.Var t.Const>
    == t.PrefixConstraint
*/
GenPrefixConstraint {
  t.Var t.Const = (OR (not t.Const starts t.Var)) 
}

/*
  <GenSuffixConstraint t.Var t.Const>
    == t.SuffixConstraint
*/
GenSuffixConstraint {
  t.Var t.Const = (OR (not t.Const ends t.Var)) 
}

/*
  <GenEmptyConstraint t.Var>
    == t.EmptyConstraint
*/
GenEmptyConstraint {
  t.Var = (OR (not empty t.Var)) 
}

/*
  Будем называть уравнение нормальным, если в нём нет совпадающих префиксов и
  суффиксов, избыточных условий и ограничений.

  <NormalizeEq t.Eq> == t.NormalEq
*/
NormalizeEq {
  t.Eq
    , <MapCompose ((TrimEquation Left) (TrimEquation Right)) t.Eq>
    : ((AreEqual (e.NormalLHS) (e.NormalRHS)) (e.Constraints) (e.Conditions))
    , <MapCompose-Acc
        (GetUniqueElems Const) ((e.NormalLHS) (e.NormalRHS))
        (/* empty accumulator */)
      > : (e.Consts)
    , <RemoveRedundantConditions
        (e.Consts) (e.Conditions) (/* empty acc */)
      > : e.NormalConditions
    , <RemoveRedundantRestrictions
        (e.Consts) (e.NormalConditions) (e.Constraints) (/* empty acc */)
      > : e.NormalConstraints
    /* ... */
    = ( /* dummy output */
        (AreEqual (e.NormalLHS) (e.NormalRHS))
        (e.NormalConstraints) (e.NormalConditions)
      );
}

/*
  <MapCompose-Acc (s.Function e.Args) (e.Lists) e.Accumulator> == e.Accumulator

  s.Function has a format <s.Function e.Args e.Accumulator> == e.Accumulator
*/
MapCompose-Acc {
  (e.Call) (e.Lists) e.Accumulator
    = <MapCompose
        (<MapCall Curry (FormTerm e.Call) e.Lists>) e.Accumulator
      >;
}

/*
  <GetUniqueElems s.Mode (e.Elems) t.Accumulator> == t.Accumulator

  s.Mode ::= Var | Const
*/
GetUniqueElems {
  s.Mode (e.Elems) (e.UniqueElems)
    , e.Elems : {
      (Var s.Letter) e.RestElems
        , s.Mode : {
          Var, <IsElemInSet (Var s.Letter) (e.UniqueElems)> : False
            = <GetUniqueElems
                s.Mode (e.RestElems) (e.UniqueElems (Var s.Letter))
              >;

          s.Other = <GetUniqueElems s.Mode (e.RestElems) (e.UniqueElems)>;
        };

      (s.Letter s.Number) e.RestElems
        , s.Mode : {
          Const, <IsElemInSet (s.Letter s.Number) (e.UniqueElems)> : False 
            = <GetUniqueElems
                s.Mode (e.RestElems) (e.UniqueElems (s.Letter s.Number))
              >;

          s.Other = <GetUniqueElems s.Mode (e.RestElems) (e.UniqueElems)>;
        };

      /* no elements */ = (e.UniqueElems);
    };
}

