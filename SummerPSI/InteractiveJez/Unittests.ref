*$INLINE HigherOrder;

/*
  Abbreviations:
  - subst: substitution;
  - elem: element;
  - var: variable;
  - restr: restriction;
*/

$EXTERN FormPair, Zip, Take, GetNextConst, IsWordInAlphabet, IsEmpty,
        LatinCapitalLetters, SubtractSets, GetUniqueValues, QuickSort,
        Partition, Overlap, IsElemInSet;
        
$ENTRY Go {
  = <Prout
      <MapCall
        Curry
        (Flip <TestSet-Pick>)
        <MapCall Curry (FormPair RunPick) 1 2 3 4>
      >
    >
    <Prout
      <UnwrapCalls
        <Zip
          (
            <MapCall
              Curry
              (FormPair RunSubstIndices)
              (
                1
                (SubstIndex i1 ((i2 2) (const 2)))
              )
              (
                2
                (SubstIndex i4 ((i1 3) (const 1)))
                (SubstIndex i1 ((i2 2) (i3 1) (const 0)))
              )
              (
                3
                (SubstIndex i4 ((i1 3) (const 1)))
                (SubstIndex i1 ((i2 2) (i3 1) (const 0)))
              )
              (
                4
                (SubstIndex i4 ((i1 3) (const 1)))
                (SubstIndex i1 ((i2 2) (i3 1) (const 0)))
              )
            >
          )
          (<TestSet-SubstIndex>)
        >
      >
    >
    <Prout
      <MapCall Plain RunPairComp <TestSet-PairComp>>
    >;
}

VariableAlphabet {
  = <MapCall
      Plain
      GenVariable
      <LatinCapitalLetters>
    >;
}

GenVariable {
  s.Name = (Var s.Name);
}

TestSet-Pick {
  = (
      (
        AreEqual
        ((Var 'X') ('A' 0))
        ((Var 'Y') ('B' 0) (Var 'Y'))
      )
      (/* No constraints */)
      (/* No index eqs */)
    )
    (
      (
        AreEqual
        (('A' 0) (Var 'X') ('A' 0))
        ((Var 'Y') ('A' 0) ('A' 0) (Var 'Y'))
      )
      (
        (OR (not empty (Var 'X')))
        (OR (not ('A' 0) starts (Var 'X')) (not ('B' 0) ends (Var 'X')))
      )
      (/* No index eqs */)
    )
    (
      (
        AreEqual
        ((Var 'X'))
        ((Var 'Y'))
      )
      (
        (OR (not empty (Var 'X')))
      )
      (/* No index eqs */)
    )
    (
      (
        AreEqual
        ((Var 'X') ('A' 0))
        (('A' 0) (Var 'Y'))
      )
      (
        (OR (not ('A' 0) ends (Var 'X')))
      )
      (/* No index eqs */)
    );
}

TestSet-SubstIndex {
  = (
      (
        AreEqual
        (('A' 2))
        (('A' 1) (Var 'X') ('A' 1))
      )
      (
        (OR (not empty (Var 'X')))
      )
      (
        (('A' 1) is (('A' 0) (i1 1) (const 0)))
        (('A' 2) is (('A' 0) (i2 2) (const 2)))
      )
    )
    (
      (
        AreEqual
        (('A' 3) (Var 'Y') ('A' 3))
        (('A' 2) (Var 'X') ('A' 1))
      )
      (/* No constraints */)
      (
        (('A' 1) is (('A' 0) (i1 3) (const 1)))
        (('A' 2) is (('A' 0) (i2 6) (i3 3) (const 1)))
        (('A' 3) is (('A' 0) (i4 1) (const 0)))
      )
    )
    (
      (
        AreEqual
        (('A' 3) (Var 'Y')('A' 1)(Var 'Y'))
        (('A' 2) (Var 'X'))
      )
      (/* No constraints */)
      (
        (('A' 1) is (('A' 0) (i1 3) (const 1)))
        (('A' 2) is (('A' 0) (i2 5) (i3 3) (const 1)))
        (('A' 3) is (('A' 0) (i4 1) (const 0)))
      )
    )
    (
      (
        AreEqual
        (('A' 3) ('B' 0) (Var 'X') ('A' 3) (Var 'Y'))
        (('A' 2) ('B' 0) (Var 'X') (Var 'Z') ('A' 2))
      )
      (/* No constraints */)
      (
        (('A' 1) is (('A' 0) (i1 3) (const 1)))
        (('A' 2) is (('A' 0) (i2 6) (i3 3) (const 1)))
        (('A' 3) is (('A' 0) (i4 1) (const 0)))
      )
    );
}

/*
  <TestSet-PairComp>
    == (s.SeqNumber (e.NewConst) (e.Const1) (e.Const2) (e.Eq)) e.Tests
*/
TestSet-PairComp {
  = (
      1
      ('A' 1)
      ('B' 0) ('A' 0)
      (
        (
          AreEqual
          ((Var 'X') ('B' 0) (Var 'Y') ('A' 0))
          ((Var 'Y') (Var 'Y') ('B' 0) ('A' 0) (Var 'X'))
        )
        (
          (OR (not empty (Var 'X')))
        )
        (/* No index equations */)
      )
    )
    (
      2
      ('A' 1)
      ('A' 0) ('B' 0)
      (
        (
          AreEqual
          ((Var 'X') ('A' 0) ('B' 0) (Var 'Y'))
          ((Var 'Y') ('B' 0) ('A' 0) (Var 'X'))
        )
        (
          (OR (not empty (Var 'Y')))
        )
        (/* No index equations */)
      )
    )
    (
      3
      ('A' 1)
      ('A' 0) ('B' 0)
      (
        (
          AreEqual
          (('B' 0) (Var 'X') (Var 'Y') ('A' 0))
          ((Var 'X') ('B' 0) (Var 'Z') (Var 'Y'))
        )
        (/* No constraints */)
        (/* No index equations */)
      )
    );
}

RunPick {
  1 e.Eqs
    , <Pick 1 e.Eqs> : {
        (e.Eq) = True;
        e.Other = False;
      };

  2 e.Eqs
    , <Pick 2 e.Eqs> : {
        (e.Eq) = True;
        e.Other = False;
      };

  3 e.Eqs
    , <Pick 3 e.Eqs> : {
        NotMinimal = True;
        e.Other = False;
      };

  4 e.Eqs
    , <Pick 4 e.Eqs> : {
        Success = True;
        e.Other = False;
      };
}

RunSubstIndices {
  (1 e.Substs) t.EqData
    , <MapCompose (e.Substs) t.EqData> : {
        /* This unit test allows the implementation to choose freely
          whether to prune equal constants from left or from right. */
        (
          (AreEqual (/* No terms */) (e.W1 (Var 'X') e.W2))
          ((OR (not empty (Var 'X'))))
          ((('A' s.Ind) is (('A' 0) (i2 2) (const 2))))
        ), e.W1 e.W2 : ('A' s.Ind) = True;

        e.Z = False;
      };

  (2 e.Substs) t.EqData
    , <MapCompose (e.Substs) t.EqData> : {
        (
          (AreEqual ((Var 'Y')) ((Var 'X')))
          (/* EMPTY */)
          (/* EMPTY */) /* All the dependencies collapsed. */
        ) = True;
        
        e.Z = False;
      };

  (3 e.Substs) t.EqData
    , <MapCompose (e.Substs) t.EqData> : {
        (
          (
            AreEqual
            (('A' s.Ind) (Var 'Y')('A' s.Ind) (Var 'Y'))
            (('A' 2) (Var 'X'))
          )
          (/* EMPTY */)
          /* The implementation can preserve either ('A' 1)
             or ('A' 3) - no choice is forced. */
          (e.IndEq1 (('A' 2) is (('A' 0) (i2 5) (i3 3) (const 1))) e.IndEq2)
        ), e.IndEq1 e.IndEq2
          : (('A' s.Ind) is (('A' 0) (i2 6) (i3 3) (const 1))) = True;

        e.Z = False;
      };

  (4 e.Substs) t.EqData
    , <MapCompose (e.Substs) t.EqData> : {
        (
          /* The equal prefixes are pruned forward up to non-equal parts. */
          (AreEqual (('A' s.Ind) (Var 'Y')) ((Var 'Z') ('A' s.Ind)))
          (/* EMPTY */)
          ((('A' s.Ind) is (('A' 0) (i2 6) (i3 3) (const 1))))
        ) = True;

        e.Z = False;
      };
}

/*
  <RunPairComp (s.SeqNumber) (e.NewConst) (e.Const1) (e.Const2) (e.Eq)>
    == True
    == False
*/
RunPairComp {
  /* TODO: fix tests */
  (1 e.Input)
    , <PairComp e.Input> : {
      ('B' 1) (e.NewEqs)
        , e.NewEqs
        : e.L1
          /* (Var 'Y') ends with ('B' 0) and starts with ('A' 0) */
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y') ('A' 1))
              (('A' 0) (Var 'Y') ('A' 1) (Var 'Y') ('B' 0) ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          /* (Var 'Y') ends with ('B' 0) and doesn't start with ('A' 0) */
          (
            (
              AreEqual
              ((Var 'X') ('B' 0) (Var 'Y') ('A' 1))
              ((Var 'Y') ('B' 0) (Var 'Y') ('B' 0) ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
              (OR (not ('A' 0) starts (Var 'Y')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          /* (Var 'Y') doesn't end with ('B' 0) and starts with ('A' 0) */
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              (('A' 0) (Var 'Y') ('A' 0) (Var 'Y') ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
              (OR (not ('B' 0) ends (Var 'Y')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          /* (Var 'Y') doesn't end with ('B' 0) and start with ('A' 0) */
          (
            (
              AreEqual
              ((Var 'X') ('B' 0) (Var 'Y') ('A' 0))
              ((Var 'Y') (Var 'Y') ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
              (OR (not empty (Var 'Y')))
              (OR (not ('A' 0) starts (Var 'Y')))
              (OR (not ('B' 0) ends (Var 'Y')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R4
        , e.L4 e.R4
        : e.L5
          /* (Var 'Y') is empty */
          (
            (
              AreEqual
              ((Var 'X') ('A' 1))
              (('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'X')))
            )
            (
              (('A' 1) is (('B' 0) (const 1)) (('A' 0) (const 1)))
            )
          )
          e.R5
        = True;
        
        e.Other = False;
    };
    
  (2 e.Input)
    , <PairComp e.Input> : {
      ('B' 1) (e.NewEqs)
        , e.NewEqs
        : e.L1
          /* (Var 'Y') ends with ('A' 0) and (Var 'X') starts with ('B' 0) */
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'Y') ('A' 1) ('A' 1) (Var 'X'))
            )
            (/* No constraints */)
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          /* (Var 'Y') ends with ('A' 0) and
             (Var 'X') doesn't start with ('B' 0) */
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'Y') ('A' 1) ('A' 0) (Var 'X'))
            )
            (
              (OR (not ('B' 0) starts (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          /* (Var 'Y') doesn't end with ('A' 0) and
             (Var 'X') starts with ('B' 0) */
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y'))
              ((Var 'Y') ('B' 0) ('A' 1) (Var 'X'))
            )
            (
              (OR (not empty (Var 'Y')))
              (OR (not ('A' 0) ends (Var 'Y')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          /* (Var 'Y') doesn't end with ('A' 0) and
             (Var 'X') doesn't start with ('B' 0) */
          (
            (
              AreEqual
              ((Var 'X') ('A' 1) (Var 'Y'))
              ((Var 'Y') ('B' 0) ('A' 0) (Var 'X'))
            )
            (
              (OR (not empty (Var 'Y')))
              (OR (not ('A' 0) ends (Var 'Y')))
              (OR (not ('B' 0) starts (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R4
        = True;
        
        e.Other = False;
    };
    
  (3 e.Input)
    , <PairComp e.Input> : {
      ('B' 1) (e.NewEqs)
        , e.NewEqs
        : e.L1
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'X') ('A' 1) (Var 'Z') ('A' 1) (Var 'Y'))
            )
            (/* No constraints */)
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R1
        , e.L1 e.R1
        : e.L2
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 1) (Var 'Y') ('A' 0))
              ((Var 'X') ('A' 1) (Var 'Z') ('B' 0) (Var 'Y'))
            )
            (
              (OR (not ('A' 0) ends (Var 'Z')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R2
        , e.L2 e.R2
        : e.L3
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('A' 0) (Var 'Y') ('A' 0))
              ((Var 'X') ('A' 1) (Var 'Z') (Var 'Y'))
            )
            (
              (OR (not ('B' 0) starts (Var 'Y')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R3
        , e.L3 e.R3
        : e.L4
          (
            (
              AreEqual
              (('B' 0) (Var 'X') ('B' 0) (Var 'Y') ('A' 0))
              ((Var 'X') ('B' 0) (Var 'Z') ('A' 1) (Var 'Y'))
            )
            (
              (OR (not ('A' 0) ends (Var 'X')))
            )
            (
              (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
            )
          )
          e.R4
        , e.L4 e.R4
        : e.L5
          (
            (
              AreEqual
              (('B' 0) (Var 'X') (Var 'Y') ('A' 0))
              ((Var 'X') ('B' 0) (Var 'Z') (Var 'Y'))
            )
            (
              (OR (not ('A' 0) ends (Var 'X')))
              (OR (not ('A' 0) ends (Var 'Z')) (not ('B' 0) starts (Var 'Y')))
            )
            (/* No index equations */)
          )
          e.R5
        = True;
        
      e.Other = False;
    };
}

/*
  <Pick s.Number e.Equations>
    == t.Equation
*/
Pick {
  1 ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions)) e.RestEquations
    , <SubtractSets
        (<GetUniqueValues Flat <MapCall Plain GetVars (e.LHS) (e.RHS)>>)
        (<GetNonEmptyVars e.Constraints>)
      >
    : (e.VarsForSubst)
    , <MapCall
        Revert
        (GenSubst (/* EMPTY */))
        e.VarsForSubst
      >
    : e.Substs
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.LHS) (e.RHS)
      >
    : {
      (e.Half) (e.Half) = Success;

      (e.NewLHS) (e.NewRHS)
        , <MapCall Plain GetConsts (e.NewLHS) (e.NewRHS)> : {
          /* No consts were found */ = NotMinimal;

          e.SomeConsts
            = ((AreEqual (e.NewLHS) (e.NewRHS)) (e.Constraints) (e.Conditions)); 
        };
    };

  s.Number t.Equation e.RestEquations = <Pick <Sub s.Number 1> e.RestEquations>;
}

/* Non-recursive substitution. */
Subst {
  (e.Substs) (e.ApplyTo)
    , e.Substs : {
      t.Subst e.RestSubsts
        = <Subst (e.RestSubsts) (<Subst-Aux t.Subst e.ApplyTo>)>;

      /* No more substs */ = (e.ApplyTo);
    };

  e.Other = <Prout 'Subst: Invalid input ' e.Other>;
}

Subst-Aux {
  t.Subst e.ApplyTo
    , t.Subst : (assign t.Old (e.New))
    , e.ApplyTo : {
      e.U1 t.Old e.U2 = e.U1 e.New <Subst-Aux t.Subst e.U2>;

      e.Other = e.Other;
    };

  e.Other = <Prout 'Subst-Aux: Invalid input ' e.Other>;
}

GenSubst {
  t.Old (e.New) = (assign t.Old (e.New));
  
  e.Other = <Prout 'GenSubst: Invalid input ' e.Other>;
}

/*
  <GetNonEmptyVars e.Constraints>
    == e.NonEmptyVars
*/
GetNonEmptyVars {
  e.L (OR (not empty (Var s.X))) e.R = (Var s.X) <GetNonEmptyVars e.R>;

  /* No appropriate disjuncts left */
  e.Other = /* EMPTY */;
}

GetVars {
  (t.Comp e.RestComps)
    , t.Comp : {
      (Var s.Name) = t.Comp <GetVars (e.RestComps)>;

      (s.Name s.Number) = <GetVars (e.RestComps)>; /* Ignore consts. */

      e.Other = <Prout 'GetVars: Invalid component ' e.Other>;
    };

  (/* No more comps */) = /* EMPTY */;

  e.Other = <Prout 'GetVars: Invalid input ' e.Other>;
}

GetConsts {
  (t.Comp e.RestComps)
    , t.Comp : {
      (Var s.Name) = <GetConsts (e.RestComps)>; /* Ignore vars. */

      (s.Name s.Number) = t.Comp <GetConsts (e.RestComps)>;
      
      e.Other = <Prout 'GetConsts: Invalid component ' e.Other>;
    };

  (/* No more comps */) = /* EMPTY */;

  e.Other = <Prout 'GetConsts: Invalid input ' e.Other>;
}

/*
  <SubstIndex s.Index (e.Subst) (e.Eq)>
    == (e.SubstEq)
*/
SubstIndex {
  s.Index (e.Multiset)
  ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.IndexEqs))
    , <MapCall
        Curry
        (SubstToIndexEq (s.Index (e.Multiset)))
        e.IndexEqs
      >
    : e.SubstIndexEqs
    , <MapCompose
        ((TrimEquation Left) (TrimEquation Right))
        ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.SubstIndexEqs))
      >
    : ((AreEqual (e.TrimmedLHS) (e.TrimmedRHS)) e.Rest)
    , <MapCall
        Curry
        (
          CheckIndexEqToCollapse
          (
            <GetUniqueValues
              Flat
              <GetConsts (e.TrimmedLHS)> <GetConsts (e.TrimmedRHS)>
            >
          )
        )
        e.SubstIndexEqs
      >
    : e.NecessaryIndexEqs
    , <ReplaceRepeatedIndexEqs
        (e.NecessaryIndexEqs)
        (/* No substitutions at start */)
      > : (e.UniqueIndexEqs) (e.Substs)
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.TrimmedLHS) (e.TrimmedRHS)
      > : (e.SubstLHS) (e.SubstRHS)
    = ((AreEqual (e.SubstLHS) (e.SubstRHS)) (e.Constraints) (e.UniqueIndexEqs));
  
  e.Other = <Prout 'SubstIndex: Invalid input ' e.Other>;
}

/*
  <SubstToIndexEq (s.Index (e.Multiset)) (e.IndexEq)> == (e.SubstIndexEq)
*/
SubstToIndexEq {
  (s.Index (e.Multiset)) ((s.Name s.Number) is (e.RHS))
    = (
        (s.Name s.Number)
        is
        (<SumUpComps /* TODO: lexicographic sort */
          <MapCall Curry (SubstToComp (s.Index (e.Multiset))) e.RHS>
        >)
      );
    
  e.Other = <Prout 'SubstToIndexEq: Invalid input ' e.Other>;
}

/*
  <SubstToComp (s.Index (e.Multiset)) (e.Comp)> == (e.SubstComp)
*/
SubstToComp {
  (s.Index (e.Multiset)) (e.Comp)
    , e.Comp : {
      s.Index s.Number = <MapCall Curry (MulComp s.Number) e.Multiset>;

      s.AnotherIndex s.Number = (e.Comp);

      e.Other = <Prout 'SubstToComp: Invalid component ' e.Other>;
    };
    
  e.Other = <Prout 'SubstToComp: Invalid input ' e.Other>;
}

/*
  <MulComp s.Multiplier (e.Comp)> == (e.MulComp)
*/
MulComp {
  s.Multiplier (s.Index s.Number) = (s.Index <Mul s.Multiplier s.Number>);
  
  e.Other = <Prout 'MulComp: Invalid input ' e.Other>;
}

/*
  <SumUpComps e.Comps> == e.SummedUpComps
*/
SumUpComps {
  e.U1 (s.Index s.Number1) e.U2 (s.Index s.Number2) e.U3
    = e.U1 e.U2 (s.Index <Add s.Number1 s.Number2>) <SumUpComps e.U3>;
    
  e.SummedUpComps = e.SummedUpComps;
}

/*
  <TrimEquation s.Mode t.Equation>
    == t.TrimmedEquation
*/
TrimEquation {
  s.Mode t.Equation
    , Left Right : e.L s.Mode e.R /* verifying the mode */
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.IndexEqs))
    , <MapCall Curry (Take s.Mode) (e.LHS) (e.RHS)> : {
      /* Both equation parts are not empty */
      (t.Elem1 e.LHS1) (t.Elem2 e.RHS1)
        , <AreElementsEqual t.Elem1 t.Elem2 (e.IndexEqs)> : {
          True
            = <TrimEquation
                s.Mode
                ((AreEqual (e.LHS1) (e.RHS1)) (e.Constraints) (e.IndexEqs))
              >;

          False = t.Equation;
        };

      /* At least one part of the equation is empty */
      e.Other = t.Equation;
    };
  
  e.Other = <Prout 'TrimEquation: Invalid input ' e.Other>;
}

/*
  <AreElementsEqual (e.Comp1) (e.Comp2) (e.IndexEqs)>
    == True
    == False
*/
AreElementsEqual {
  (e.Comp1) (e.Comp2) (e.IndexEqs)
    , (e.Comp1) (e.Comp2) : {
      (s.Type s.Value) (s.Type s.Value) = True;

      (Var s.Value1) (Var s.Value2) = False;

      (s.Type s.Value1) (s.Type s.Value2)
        , <MapCall Curry (GetIndexEq (e.IndexEqs)) (e.Comp1) (e.Comp2)> : {
          ((e.Comp1) is (e.RHS)) ((e.Comp2) is (e.RHS)) = True;
              
          e.DifferentIndexEqs = False;
        };
        
      (s.Type1 s.Value1) (s.Type2 s.Value2) = False;

      e.Other = <Prout 'AreElementsEqual: Invalid components ' e.Other>;
    };

  e.Other = <Prout 'AreElementsEqual: Invalid input ' e.Other>;
}

/*
  <GetIndexEq (e.IndexEqs) (e.Comp)>
    == (e.IndexEq)
    == ε
*/
GetIndexEq {
  ((e.IndexEq) e.RestIndexEqs) (e.Comp)
    , e.IndexEq : {
      (e.Comp) is (e.RHS) = (e.IndexEq);

      e.AnotherIndexEq = <GetIndexEq (e.RestIndexEqs) (e.Comp)>;
    };

  /* Abnormal case */
  (/* No more index equations */) (e.Comp) = /* EMPTY */;
}

/*
  <CheckIndexEqToCollapse (e.Consts) (e.IndexEq)>
    == (e.IndexEq)
    == ε
*/
CheckIndexEqToCollapse {
  (e.U1 (e.Comp) e.U2) ((e.Comp) is (e.RHS)) = ((e.Comp) is (e.RHS));
    
  (e.Consts) (e.NotInvolvedIndexEq) = /* EMPTY */;

  e.Other = <Prout 'CheckIndexEqToCollapse: Invalid input ' e.Other>;
}

/*
  <ReplaceRepeatedIndexEqs (e.IndexEqs) (e.Substs)>
    == (e.ReplacedIndexEqs) (e.Substs)
*/
ReplaceRepeatedIndexEqs {
  (
    e.U1
    ((e.Comp1) is (e.RHS))
    e.U2
    ((e.Comp2) is (e.RHS))
    e.U3
  )
  (e.Substs) 
    = <ReplaceRepeatedIndexEqs
        (e.U1 ((e.Comp1) is (e.RHS)) e.U2 e.U3)
        (<GenSubst (e.Comp2) ((e.Comp1))> e.Substs)
      >;
      
  (e.UniqueIndexEqs) (e.Substs) = (e.UniqueIndexEqs) (e.Substs);
  
  e.Other = <Prout 'ReplaceRepeatedIndexEqs: Invalid input ' e.Other>;
}

/*
  <PairComp t.ReplacingConst t.Const1 t.Const2 t.Equation>
    == t.NewReplacingConst (e.Equations)
*/
PairComp {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    = <GetNextConst t.ReplacingConst>
      (
        <HandleEmptySubsts
          t.ReplacingConst t.Const1 t.Const2 t.Equation
        >
      );
}

/*
  If an essentially empty substitution is possible, recursively calls itself
  with an applied and not applied substitution equations. Otherwise, transfers
  control to the `HandleNonEmptySubsts` function.
  
  <HandleEmptySubst
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    /* Calling `GetEmptySubst` is quite expensive, so here's
       used `CallTill` not to make redundant calculations with `MapCall` */
    , <CallTill
        (/* EMPTY */)
        Curry
        (
          GetEmptySubst
          t.Const1 t.Const2 (e.Constraints)
        )
        (e.LHS) (e.RHS)
      >
    : {
      /* Found an essentially empty substitution */
      t.Subst
        = /* Calling with performed substitution */
          <HandleEmptySubsts 
            t.ReplacingConst t.Const1 t.Const2
            (
              (
                AreEqual
                <MapCall Curry (Subst (t.Subst)) (e.LHS) (e.RHS)>
              )
              (e.Constraints)
              (e.Conditions)
            )
          >
          /* Calling with not performed substitution */
          <HandleEmptySubsts
            t.ReplacingConst t.Const1 t.Const2
            (
              (AreEqual (e.LHS) (e.RHS))
              (e.Constraints (OR <DenySubst t.Subst>))
              (e.Conditions)
            )
          >;
      
      /* No essentially empty substitution is found. */
      /* EMPTY */
        = <HandleNonEmptySubsts
            t.ReplacingConst t.Const1 t.Const2 t.Equation
          >;
    };
}

/*
  Returns any essentially empty substitution possible in the given equation
  half. If no such substitution is found, returns ε.
  
  <GetEmptySubst
    t.Const1 t.Const2 (e.Constraints) (e.EquationHalf)
  >
    == t.Subst
    == ε
*/
GetEmptySubst {
  t.Const1 t.Const2 (e.Constraints) (e.EquationHalf)
    /* Saving the result of frequently called functions */
    , <VariableAlphabet> : e.Vars
    , <GetNonEmptyVars e.Constraints> : e.NonEmptyVars
    , e.EquationHalf : {
      e.L t.Const1 e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            (e.Vars)
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVariable e.RestVars)
        = <GenSubst t.SubstVariable (/* EMPTY */)>;
        
      e.L t.Const1 e.M (Var s.X) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVariable e.RestVars)
        = <GenSubst t.SubstVariable (/* EMPTY */)>;

      e.L (Var s.X) e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVariable e.RestVars)
        = <GenSubst t.SubstVariable (/* EMPTY */)>;

      e.L (Var s.X) e.M  (Var s.Y) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X) (Var s.Y))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVariable e.RestVars)
        = <GenSubst t.SubstVariable (/* EMPTY */)>;
        
      /* No essentially empty substitutions for this half of the equation */
      e.Other = /* EMPTY */;
    };
}

/*
  Finds and applies essentially non-empty substitutions to the equation. 
  
  <HandleNonEmptySubsts
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleNonEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation
    : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    , <GetNonEmptySubsts 
        t.Const1 t.Const2 (e.Constraints) (e.Conditions)
        <GetNonEmptySubsts
          t.Const1 t.Const2 (e.Constraints) (e.Conditions)
          (/* No discovered elementary substitutions at start */)
          (/* No discovered composite substitutions at start */)
          (e.LHS)
        >
        (e.RHS)
      >
    : (e.ElementarySubsts) (e.CompositeSubsts)
    , <CartesianProductOfOptionSets
        <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
      >
    : (e.MultipliedOptions) /* what if no options initially? */
    , <MapCall
        Plain
        ProcessOption
        e.MultipliedOptions
      >
    : e.ProcessedOptions /* remove duplicates? */
    , <MapCall
        Revert
        (ApplyOption t.Equation)
        e.ProcessedOptions
      >
    : e.Equations /* duplicated equations? */
    /* ... */
      = /* New equations */;
}

/*
  Returns essentially non-empty substitutions for the given equation half.
  
  <GetNonEmptySubst
    t.Const1 t.Const2 (e.Constraints) (e.Conditions)
    (e.DiscoveredElementarySubsts) (e.DiscoveredCompositeSubsts) (e.Elems)
  >
    == e.Substs
*/
GetNonEmptySubsts {
  t.Const1 t.Const2 (e.Constraints) (e.Conditions)
  (e.ElementarySubsts) (e.CompositeSubsts) (e.Elems)
    , e.Elems : {
      (Var s.X) (Var s.Y) e.RestElems
        , <GenSubst (Var s.X) ((Var s.X) t.Const1)> : t.Subst1
        , <GenSubst (Var s.Y) (t.Const2 (Var s.Y))> : t.Subst2
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.Y) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts (t.Subst1 t.Subst2))
            ((Var s.Y) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet (t.Subst1 t.Subst2) (e.CompositeSubsts)> : {
            /* The substitution is already processed. */
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.ConstX ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.ConstX
                      (t.Const1 <GetLast t.Const1 (e.Conditions)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False
                        ,  e.L e.R : {
                          e.L1 (OR (not t.ConstY starts (Var s.Y))) e.R1
                            , <IsElemInSet
                                t.ConstY
                                (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                              > : {
                                /* The substitution is impossible. */
                                True = <UnwrapCalls t.SkipSubst>;

                                False = <UnwrapCalls t.AddSubst>;
                              };
                          
                          /* No constraint on the substitution. */
                          e.L e.R = <UnwrapCalls t.AddSubst>;
                        };
                    };

                /* No constraint on the first substitution. */
                e.L (OR (not t.ConstY starts (Var s.Y))) e.R
                  , <IsElemInSet
                      t.ConstY
                      (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;

                      False = <UnwrapCalls t.AddSubst>;
                    };

                /* No constraints on the substitutions. */
                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Const1 (Var s.X) e.RestElems
        , <GenSubst (Var s.X) (t.Const2 (Var s.X))> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.Const starts (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };
        
      (Var s.X) t.Const2 e.RestElems
        , <GenSubst (Var s.X) ((Var s.X) t.Const1)> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            (e.RestElems) /* can skip t.Const2 */
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            (e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.Const ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const1 <GetLast t.Const1 (e.Conditions)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Elem1 t.Elem2 e.RestElems
        , t.Elem2 : {
          t.Const1
            = <GetNonEmptySubsts
                t.Const1 t.Const2 (e.Constraints) (e.Conditions)
                (e.ElementarySubsts) (e.CompositeSubsts)
                (t.Const1 e.RestElems)
              >;

          t.Elem2
            = <GetNonEmptySubsts
                t.Const1 t.Const2 (e.Constraints) (e.Conditions)
                (e.ElementarySubsts) (e.CompositeSubsts)
                (e.RestElems) /* can skip t.Elem2 */
              >;
        };

      e.OneOrNoTerm = (e.ElementarySubsts) (e.CompositeSubsts);
    };
}

/*
  Returns the First-elements of the constant.

  <GetFirst t.Const (e.Conditions)>
    == e.FirstElems
*/
GetFirst {
  t.Const (e.Conditions)
    , e.Conditions : {
      e.L (t.Const is (t.FirstElem e.Details) e.Elems) e.R
        = t.FirstElem <GetFirst t.FirstElem (e.L e.R)>;

      /* No condition for the constant. */
      e.Conditions = /* EMTPY */;
    };
}

/*
  Returns the Last-elements of the constant.

  <GetLast t.Const (e.Conditions)>
    == e.LastElems
*/
GetLast {
  t.Const (e.Conditions)
    , e.Conditions : {
      e.L (t.Const is e.Elems (t.LastElem e.Details)) e.R
        = t.LastElem <GetLast t.LastElem (e.L e.R)>;
      
      /* No condition for the constant. */
      e.Conditions = /* EMPTY */;
    };
}

/*
  <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
    == e.OptionSets
*/
GenOptionSets {
  (e.ElementarySubsts) (e.CompositeSubsts)
    , <GetUniqueValues
        Flat
        <MapCall
          Revert
          (GetSpecialSubsts (e.ElementarySubsts))
          e.CompositeSubsts
        >
      >
    : e.SpecialSubsts
    , <SubtractSets (e.ElementarySubsts) (e.SpecialSubsts)>
    : (e.UnprocessedElementarySubsts)
    = <MapCall
        Revert
        (GenOptionSetFromCompositeSubst (e.SpecialSubsts))
        e.CompositeSubsts
      >
      <MapCall
        Plain
        GenOptionSetFromElementarySubst
        e.UnprocessedElementarySubsts
      >;
}

/*
  For the equation, we call an essential elementary substitution "special"
  if it is present in some essential composite substitution.
  
  <GetSpecialSubsts t.CompositeSubst (e.ElementarySubsts)>
    == e.SpecialSubsts
*/
GetSpecialSubsts {
  (t.Subst1 t.Subst2) (e.ElementarySubsts)
    , e.ElementarySubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is essential too. */
          e.L1 t.Subst2 e.R1 = t.Subst1 t.Subst2;

          /* Only the first substitution is essential. */
          e.Other = t.Subst1;
        };

      /* Only the second substitution is essential. */
      e.L t.Subst2 e.R = t.Subst2;

      /* None of the substitutions are essential. */
      e.Other = /* EMPTY */;
    };
}

/*
  <GenOptionSetFromCompositeSubst t.CompositeSubst (e.SpecialSubsts)>
    == e.OptionSet
*/
GenOptionSetFromCompositeSubst {
  (t.Subst1 t.Subst2) (e.SpecialSubsts)
    , e.SpecialSubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is special too. */
          e.L1 t.Subst2 e.R1
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <DenySubst t.Subst2>)
                  )
                )
                (
                  (t.Subst2)
                  (
                    (OR <DenySubst t.Subst1>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <DenySubst t.Subst1>)
                    (OR <DenySubst t.Subst2>)
                  )
                )
              );

          /* Only the first substitution is special. */
          e.Other
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <DenySubst t.Subst2>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <DenySubst t.Subst1>)
                  )
                )
              );
        };

      /* Only the second substitution is special. */
      e.L t.Subst2 e.R
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (t.Subst2)
              (
                (OR <DenySubst t.Subst1>)
              )
            )
            (
              (/* No substitutions */)
              (
                (OR <DenySubst t.Subst2>)
              )
            )
          );

      /* None of the substitutions are special. */     
      e.Other
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (/* No substitutions */)
              (
                (
                  OR
                  <DenySubst t.Subst1>
                  <DenySubst t.Subst2>
                )
              )
            )
          );
    };
}

/*
  <DenySubst t.ElementarySubst>
    == t.Restriction
*/
DenySubst {
  (assign t.Var (e.NewValue))
    , e.NewValue : {
      t.Var t.Const = (not t.Const ends t.Var);

      t.Const t.Var = (not t.Const starts t.Var);

      /* EMPTY */ = (not empty t.Var);
    };
}

/*
  <GenOptionSetFromElementarySubst t.ElementarySubst>
    == e.OptionSet
*/
GenOptionSetFromElementarySubst {
  t.Subst
    = (
        (
          (t.Subst)
          (/* No constraints */)
        )
        (
          (/* No substitutions */)
          (
            (OR <DenySubst t.Subst>)
          )
        )
      );
}

/*
  <CartesianProductOfOptionSets e.OptionSets>
    == (e.MultipliedOptions)
*/
CartesianProductOfOptionSets {
  (e.Set1) (e.Set2) e.RestSets
    = <CartesianProductOfOptionSets 
        <CartesianProduct Overlap (e.Set1) (e.Set2)> e.RestSets
      >;

  (e.Set) = (e.Set);

  /* No sets */ = (/* EMPTY */);
}

/*
  Removes duplicates, redundant constraints and checks for consistency.
  
  <ProcessOption t.Option>
    == t.ProcessedOption
    == ε
*/
ProcessOption {
  ((e.Substs) (e.Constraints))
    , <MapCall
        Curry
        (GetUniqueValues Wrap)
        (e.Substs) (e.Constraints)
      >
    : (e.UniqueSubsts) (e.UniqueConstraints)
    , <RemoveRedundantConstraints e.UniqueConstraints>
    : e.NecessaryConstraints
    = <FixOptionConsistency
        ((e.UniqueSubsts) (e.NecessaryConstraints))
        (/* No checked substitutions at start */)
      >;
}

/*
  <RemoveRedundantConstraints e.Constraints>
    == e.NecessaryConstraints
*/
RemoveRedundantConstraints {
  /* Found a non-trivial disjunct */
  e.L (OR t.Restr1 t.Restr2) e.R
    , e.L e.R : {
      /* The disjunct is performed by the first restriction */
      e.L1 (OR t.Restr1) e.R1 = e.L <RemoveRedundantConstraints e.R>;

      /* The disjunct is performed by the second restriction */
      e.L1 (OR t.Restr2) e.R1 = e.L <RemoveRedundantConstraints e.R>;

      /* The disjunct isn't performed trivially */
      e.Other
        = e.L (OR t.Restr1 t.Restr2) <RemoveRedundantConstraints e.R>;
    };

  /* No non-trivial disjuncts were found */
  e.TrivialDisjuncts = e.TrivialDisjuncts;
}

/*
  Checks an option for consistency and fixes avoidable contradictions
  whenever necessary. If an unavoidable condradiction is found, returns ε.
  Otherwise, returns the processed option.
  
  <FixOptionConsistency t.Option (e.CheckedSubsts)>
    == t.FixedOption
    == ε
*/
FixOptionConsistency {
  ((t.Subst e.RestSubsts) (e.Constraints)) (e.CheckedSubsts)
    , <DenySubst t.Subst> : t.Restr
    , e.Constraints : {
      /* Found a disjunct containing the restriction */
      e.L (OR e.L1 t.Restr e.R1) e.R
        , e.L1 e.R1 : {
          /* Trivial disjunct. Unavoidable contradiction */
          /* EMPTY */ = /* EMPTY */;

          /* Force another restriction to be executed and try to find other
             non-trivial disjuncts containing the substitution */
          t.AnotherRestr
            = <FixOptionConsistency
                ((t.Subst e.RestSubsts) (e.L (OR t.AnotherRestr) e.R))
                (e.CheckedSubsts)
              >;
        };

      /* No contradiction is found */
      e.Other
        = <FixOptionConsistency
            ((e.RestSubsts) (e.Constraints))
            (e.CheckedSubsts t.Subst)
          >;
    };

  /* Option is successfully checked (and fixed) */
  ((/* No unchecked substitutions */) (e.Constraints)) (e.Substs)
    = ((e.Substs) (e.Constraints));
}

/*
  Applies substitutions of the option to the equation, adds constraints of the
  option to the equation's ones, cleans all up and returns the result.
  
  <ApplyOption t.Option t.Equation>
    == t.NewEquation
*/
ApplyOption {
  ((e.Substs) (e.NewConstraints))
  ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.LHS) (e.RHS)
      >
    : (e.SubstitutedLHS) (e.SubstitutedRHS)
    , <MapCompose
        ((TrimEquation Left) (TrimEquation Right))
        (
          (AreEqual (e.SubstitutedLHS) (e.SubstitutedRHS))
          (e.Constraints) (e.Conditions)
        )
      >
    : ((AreEqual (e.TrimmedLHS) (e.TrimmedRHS)) e.Rest)
    /* ... */
      /* Dummy output */
      = ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions));
}
  
/* TODO: move to the Auxiliaries.ref all the following functions. */

/*
  Cartesian product of two arbitary sets with custom pair processing function.
  
  <CartesianProduct s.ProcessingFunction (e.Set1) (e.Set2)>
    == (e.MultipliedElements)
*/
CartesianProduct {
  s.ProcessingFunction (e.Set1) (e.Set2)
    = (<MapCall
        Curry
        (CartesianProduct-Aux s.ProcessingFunction (e.Set2))
        e.Set1
      >);
}

CartesianProduct-Aux {
  s.ProcessingFunction (e.Set) t.Elem
    = <MapCall Curry (s.ProcessingFunction t.Elem) e.Set>;
}

