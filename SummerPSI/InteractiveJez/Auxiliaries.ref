$ENTRY GetNewIndex {
 s.OldIndex
 , <Explode s.OldIndex> : s.Letter s.FirstDigit e.Digits
 , <Symb <Add <Numb s.FirstDigit e.Digits> 1>> : e.NewNumber
  = <Implode s.Letter e.NewNumber>;
}

/*Throws `Recognition Impossible` if the lists have not equal lengths. */
$ENTRY Zip {
 (t.X e.X) (t.Y e.Y)
  = (t.X t.Y) <Zip (e.X)(e.Y)>;
 (/* EMPTY */)(/* EMPTY */) = /* EMPTY */;
}

$ENTRY FormPair {
   t.First t.Second = (t.First t.Second);
}

$ENTRY BelongsTo {
  t.X (e.U1 t.X e.U2) = True;
  e.Other = False;
}

$ENTRY Trim {
  e.X' 'e.Y = e.X<Trim e.Y>;
  e.Z = e.Z;
}

$ENTRY Arrange {
 Normal (e.1) (e.2) = e.1 e.2;
 Inverse (e.1) (e.2) = e.2 e.1;
}

$ENTRY Take {
  Left (t.Term e.Expr) = (t.Term e.Expr);
  Right (e.Expr t.Term) = (t.Term e.Expr);
  s.AnyMode (/* No term */) = (/* EMPTY */);
}

$ENTRY Unwrap {
  (e.Preamble)(e.Preamble e.Val) = e.Val;
  (e.Preamble)e.Preamble e.Val = e.Val;
  (e.Preamble) e.Val = e.Val;
}

$ENTRY Wrap {
  Plain s.Order (e.Preamble) e.Val = <Arrange s.Order (e.Preamble) (e.Val)>;
  Inner s.Order (e.Preamble) e.Val = (<Arrange s.Order (e.Preamble) (e.Val)>);
  Combined s.Order (e.Preamble) e.Val = <Arrange s.Order (e.Preamble) ((e.Val))>;
}

$ENTRY StructParens {
  e.Arg = <ExtractRealParens Plain e.Arg>; 
}

ExtractRealParens {
 Plain e.x'('e.y')'e.z
 , e.y : {
   e.y1'('e.y2
   , <ExtractRealParens Left () e.y2> : 
  {() e.v2
    = <ExtractRealParens Plain e.x'('e.y1 (e.v2) e.z>;
   (e.v1'(') e.v2
    = <ExtractRealParens Plain e.x'('e.y1'('e.v1 (e.v2) e.z>;
  };
   e.other = <ExtractRealParens Plain e.x (e.y) e.z>;
 };
 Left (e.drop) e.y
 , e.y : 
  {e.y1'('e.y2
     = <ExtractRealParens Left (e.drop e.y1'(')e.y2>;
   e.z = (e.drop) e.y;
  };
 Plain e.Rest = e.Rest;
}

$ENTRY ChooseMax {
 s.Val1 s.Val2
 , <Compare s.Val1 s.Val2> :
 {'+' = s.Val1;
  s.Any = s.Val2;
 };
}


*$ENTRY Go { = <Prout <GetNewIndex i19>>;}

