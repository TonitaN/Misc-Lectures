/*
  <GetNewIndex t.Index>
    == t.NewIndex
*/
$ENTRY GetNewIndex {
  s.OldIndex
    , <Explode s.OldIndex> : s.Letter s.FirstDigit e.Digits
    , <Symb <Add <Numb s.FirstDigit e.Digits> 1>> : e.NewNumber
    = <Implode s.Letter e.NewNumber>;
}

/*
  <GetNewConst t.Const>
    == t.NextConst
*/
$ENTRY GetNewConst {
  (s.Letter s.Number)
    , <LatinCapitalLetters> : {
      e.U1 s.Letter s.NextLetter e.U2 = (s.NextLetter s.Number);

      s.FirstLetter e.U s.Letter = (s.FirstLetter <Add s.Number 1>);
    };
}

/*
  <SubtractSets (e.FirstSet) (e.SecondSet)
    == (e.FirstSetWithoutSecond)
*/
$ENTRY SubtractSets {
  (e.U1 t.CommonElement e.U2) (e.V1 t.CommonElement e.V2)
    = <SubtractSets (e.U1 e.U2) (e.V1 e.V2)>;

  /* No common elements */
  t.Reduced t.Subtracted = t.Reduced;
}

/*
  <GetUniqueValues s.Mode e.Expr>
    == e.UniqueExpr
*/
$ENTRY GetUniqueValues {
  Flat e.U1 t.X e.U2 t.X e.U3 = <GetUniqueValues Flat e.U1 t.X e.U2 e.U3>;
  
  Wrap (e.U1 t.X e.U2 t.X e.U3) = <GetUniqueValues Wrap (e.U1 t.X e.U2 e.U3)>;
  
  s.AnyMode e.AlreadyUnique = e.AlreadyUnique;
}

/*
  <IsEmpty e.Any>
    == True
    == False
*/
$ENTRY IsEmpty {
  /* EMPTY */ = True;

  e.Other = False;
}

/*
  <QuickSort s.LessFunc e.List>
    == e.SortedList
*/
$ENTRY QuickSort {
  s.LessFunc e.List
    , e.List : {
      /* Empty list */ = /* EMPTY */;
      
      t.Pivot e.Tail
        , <Partition s.LessFunc () t.Pivot () e.Tail>
        : (e.Left) t.Pivot (e.Right)
        = <QuickSort s.LessFunc e.Left>
          t.Pivot
          <QuickSort s.LessFunc e.Right>;
    };
}
 
/*
  <Partition s.LessFunc (e.Left) t.Pivot (e.Right) e.List>
    == (e.NewLeft) t.Pivot (e.NewRight)
*/
$ENTRY Partition {
  s.LessFunc (e.Left) t.Pivot (e.Right) e.List
    , e.List : {
      /* Empty list */ = (e.Left) t.Pivot (e.Right);
      
      t.X e.Tail 
        , <Mu s.LessFunc t.X t.Pivot> : {
          True = <Partition s.LessFunc (e.Left t.X) t.Pivot (e.Right) e.Tail>;

          False = <Partition s.LessFunc (e.Left) t.Pivot (e.Right t.X) e.Tail>;
        };
    };
}

/* Throws `Recognition Impossible` if the lists have not equal lengths. */
$ENTRY Zip {
  (t.X e.X) (t.Y e.Y) = (t.X t.Y) <Zip (e.X) (e.Y)>;
    
  (/* EMPTY */) (/* EMPTY */) = /* EMPTY */;
}

/*
  Concatenation of corresponding elements of two lists of equal length.
  
  <Overlap ((e.X) e.Xs) ((e.Y) e.Ys)>
    == ((e.X e.Y) e.Rest)
*/
$ENTRY Overlap {
  ((e.X) e.Xs) ((e.Y) e.Ys) = <Overlap (e.Xs (e.X e.Y)) (e.Ys)>;
    
  (e.OverlappedLists) (/* EMPTY */) = (e.OverlappedLists);
}

$ENTRY FormPair {
  t.First t.Second = (t.First t.Second);
}

$ENTRY Trim {
  e.X ' ' e.Y = e.X <Trim e.Y>;
  
  e.Z = e.Z;
}

$ENTRY Arrange {
  Normal (e.1) (e.2) = e.1 e.2;
  
  Inverse (e.1) (e.2) = e.2 e.1;
}

$ENTRY Take {
  Left (t.Term e.Expr) = (t.Term e.Expr);
  
  Right (e.Expr t.Term) = (t.Term e.Expr);
  
  s.AnyMode (/* No term */) = (/* EMPTY */);
}

$ENTRY Unwrap {
  (e.Preamble) (e.Preamble e.Val) = e.Val;
  
  (e.Preamble) e.Preamble e.Val = e.Val;
  
  (e.Preamble) e.Val = e.Val;
}

$ENTRY Wrap {
  Plain s.Order (e.Preamble) e.Val
    = <Arrange s.Order (e.Preamble) (e.Val)>;
    
  Inner s.Order (e.Preamble) e.Val
    = (<Arrange s.Order (e.Preamble) (e.Val)>);
    
  Combined s.Order (e.Preamble) e.Val
    = <Arrange s.Order (e.Preamble) ((e.Val))>;
}

/*
  <IsWordInAlphabet (e.Word) (e.Alphabet)>
    == True
    == False
*/
$ENTRY IsWordInAlphabet {
  (e.Word) (e.Alphabet)
    , e.Word : {
      t.Letter e.RestWord
        , e.Alphabet : {
          e.L t.Letter e.R = <IsWordInAlphabet (e.RestWord) (e.Alphabet)>;

          e.Other = False;
        };

      /* Let's assume an empty word belongs to any alphabet */
      /* EMPTY */ = True;
    };
}

$ENTRY LatinCapitalLetters {
  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
}

/*
  <IsElemInSet t.Elem (e.Set)>
    == True
    == False
*/
$ENTRY IsElemInSet {
  t.Elem (e.Set)
    , e.Set : {
      e.L t.Elem e.R = True;

      e.Set = False;
    };
}

$ENTRY FormTerm {
  e.Any = (e.Any);
}

$ENTRY StructParens {
  e.Arg = <ExtractRealParens Plain e.Arg>; 
}

ExtractRealParens {
 Plain e.x'('e.y')'e.z
 , e.y : {
   e.y1'('e.y2
   , <ExtractRealParens Left () e.y2> : 
  {() e.v2
    = <ExtractRealParens Plain e.x'('e.y1 (e.v2) e.z>;
   (e.v1'(') e.v2
    = <ExtractRealParens Plain e.x'('e.y1'('e.v1 (e.v2) e.z>;
  };
   e.other = <ExtractRealParens Plain e.x (e.y) e.z>;
 };
 Left (e.drop) e.y
 , e.y : 
  {e.y1'('e.y2
     = <ExtractRealParens Left (e.drop e.y1'(')e.y2>;
   e.z = (e.drop) e.y;
  };
 Plain e.Rest = e.Rest;
}

$ENTRY ChooseMax {
 s.Val1 s.Val2
 , <Compare s.Val1 s.Val2> :
 {'+' = s.Val1;
  s.Any = s.Val2;
 };
}

