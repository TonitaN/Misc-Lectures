*$INLINE HigherOrder;

/*
  ABBREVIATIONS.

  (elem)ent
  (eq)uation
  (exp)onent
  (comp)ression
  (cond)ition
  (const)ant
  (constr)aint
  (gen)erate
  (restr)iction
  (triv)ial
  (subst)itution
  (var)iable
*/

/*
  DATA STRUCTURES.
  
  t.Eq ::= ((AreEqual (t.Elem*) (t.Elem*)) (t.Constr*) (t.Cond*))

  t.Elem ::= t.Const | t.Var
  t.Const ::= (s.LETTER s.NUMBER)
  t.Var ::= (Var s.LETTER)

  t.Constr ::= t.TrivConstr | t.NonTrivConstr
  t.TrivConstr ::= (OR t.Restr)
  t.NonTrivConstr ::= (OR t.SuffixRestr t.PrefixRestr)

  t.Restr ::= t.PrefixRestr | t.SuffixRestr | t.EmptinessRestr
  t.PrefixRestr ::= (not t.Const starts t.Var)
  t.SuffixRestr ::= (not t.Const ends t.Var)
  t.EmptinessRestr ::= (not empty t.Var)

  t.Cond ::= t.PairCond | t.PairCond
  t.PairCond ::= (t.Const is (t.Const (const 1)) (t.Const (const 1)))
  t.BlockCond ::= (t.Const is (t.Const t.Exp* (const s.NUMBER)))
  t.Exp ::= (s.WORD s.NUMBER)

  t.Option ::= ((t.Subst*) (t.Constr*) (t.Constr*))
  t.Subst  ::= (assign (e.ANY) (e.ANY))
*/

/*
  <Pick s.NUMBER e.Eqs> == t.Eq
*/
$ENTRY Pick {
  s.Number t.Eq e.RestEqs
    , s.Number : {
      1, t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
        , <MapCompose
            ((GetVars (e.LHS)) (GetVars (e.RHS))) (/* no vars at start */)
          > : (e.Vars)
        , <SubtractSets
            (e.Vars) (<GetNonEmptyVars e.Constrs>)
          > : (e.EmptyVars)
        , <MapCall
            Revert (GenSubst (/* empty */))
            <MapCall Plain Wrap e.EmptyVars>
          > : e.Substs
        , <MapCall
            Curry (Subst (e.Substs)) (e.LHS) (e.RHS)
          > : {
          (e.Elems) (e.Elems) = Success;

          (e.NewLHS) (e.NewRHS)
            , <MapCompose
                ((GetConsts (e.NewLHS)) (GetConsts (e.NewRHS)))
                (/* no consts at start */)
              > : {
              (/* no consts */) = NotMinimal;

              (e.SomeConsts)
                = ((AreEqual (e.NewLHS) (e.NewRHS)) (e.Constrs) (e.Conds)); 
            };
        };

      s.Other = <Pick <Sub s.Number 1> e.RestEqs>;
    };
}

/*
  <GetVars (e.Elems) (e.UniqueVars)> == (e.UniqueVars)
*/
GetVars {
  (e.Elems) (e.UniqueVars)
    , e.Elems : {
      e.L (Var s.Char) e.R
        , <IsElemInSet (Var s.Char) (e.UniqueVars)> : False
        = <GetVars (e.R) (e.UniqueVars (Var s.Char))>;

      e.Other = (e.UniqueVars);
    };
}

/*
  <IsElemInSet t.Elem (e.Set)>
    == True
    == False
*/
IsElemInSet {
  t.Elem (e.Set)
    , e.Set : {
      e.L t.Elem e.R = True;

      e.Other = False;
    };
}

/*
  <SubtractSets t.Set1 t.Set2> == t.Set
*/
SubtractSets {
  (e.L1 t.Elem e.R1) (e.L2 t.Elem e.R2)
    = <SubtractSets (e.L1 e.R1) (e.L2 e.R2)>;

  t.Set1 t.Set2 = t.Set1; /* no common elements */
}

/*
  A variable is called non-empty if there is a restriction to its emptiness.
  Otherwise, the variable is called empty.

  <GetNonEmptyVars e.Constrs> == e.Vars
*/
GetNonEmptyVars {
  e.L (OR (not empty (Var s.X))) e.R = (Var s.X) <GetNonEmptyVars e.R>;

  e.Other = /* empty */;
}

/*
  <Wrap e.Any> == (e.Any)
*/
Wrap {
  e.Any = (e.Any);
}

/*
  <GenSubst (e.OldElems) (e.NewElems)> == t.Subst
*/
GenSubst {
  (e.Old) (e.New) = (assign (e.Old) (e.New));
}

/*
  <Subst (e.Substs) (e.Expr)> == (e.NewExpr)
*/
Subst {
  (e.Substs) (e.Expr)
    , e.Substs : {
      t.Subst e.RestSubsts
        = <Subst (e.RestSubsts) (<Subst-Aux t.Subst e.Expr>)>;

      /* no substs */ = (e.Expr);
    };
}

Subst-Aux {
  t.Subst e.Expr
    , t.Subst : (assign (e.Old) (e.New))
    , e.Expr : {
      e.L e.Old e.R = e.L e.New <Subst-Aux t.Subst e.R>;

      e.Other = e.Other;
    };
}

/*
  <GetConsts (e.Elems) (e.UniqueConsts)> == (e.UniqueConsts)
*/
GetConsts {
  (e.Elems) (e.UniqueConsts)
    , e.Elems : {
      e.L (s.Char s.Number) e.R
        , <AreEqual s.Char Var> : False
        , <IsElemInSet (s.Char s.Number) (e.UniqueConsts)> : False
        = <GetConsts (e.R) (e.UniqueConsts (s.Char s.Number))>;

      e.Other = (e.UniqueConsts);
    };
}

/*
  <AreEqual t.Elem1 t.Elem2>
    == True
    == False
*/
AreEqual {
  t.Elem t.Elem = True;

  e.Other = False;
}

/*
  <SubstIndex s.Index (e.Exps) t.Eq> == t.NewEq
*/
$ENTRY SubstIndex {
  s.Index (e.Exps) ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    , <SubstExpsToConds
        s.Index (e.Exps) (e.Conds)
        (/* no conds at start */) (/* no substs at start */)
      > : (e.ReplacedConds) (e.CollapsedConstsSubsts)
    , <ReplaceRepeatedConds
        (e.ReplacedConds) (/* no substs at start */)
      > : (e.UniqueConds) (e.RepeatedConstsSubsts)
    , <MapCall
        Curry (Subst (e.CollapsedConstsSubsts e.RepeatedConstsSubsts))
        (e.LHS) (e.RHS)
      > : (e.ReplacedLHS) (e.ReplacedRHS)
    = <NormalizeEq
        ((AreEqual (e.ReplacedLHS) (e.ReplacedRHS)) (e.Constrs) (e.UniqueConds))
      >;
}

/*
  <SubstExpsToConds s.Index (e.Exps) (e.Conds) (e.ProcessedConds) (e.Substs)>
    == (e.ProcessedConds) (e.Substs)
*/
SubstExpsToConds {
  s.Index (e.Exps) (e.Conds) (e.ProcessedConds) (e.Substs)
    , e.Conds : {
      e.L (t.Const is t.Block) e.R /* skipping pair conds */
        , <SubstExpsToBlock s.Index (e.Exps) t.Block> : {
          /* block collapsed */
            = <SubstExpsToConds
                s.Index (e.Exps) (e.R) (e.ProcessedConds e.L)
                (e.Substs <GenSubst (t.Const) (/* empty */)>)
              >;
          
          t.NewBlock
            = <SubstExpsToConds
                s.Index (e.Exps) (e.R)
                (e.ProcessedConds e.L (t.Const is t.NewBlock)) (e.Substs)
              >;
        };

      e.Other = (e.ProcessedConds e.Conds) (e.Substs);
    };
}

/*
  <SubstExpsToBlock s.Index (e.Exps) t.Block>
    == t.NewBlock
    == empty
*/
SubstExpsToBlock {
  s.Index (e.Exps) (t.BlockConst e.OldExps)
    , e.OldExps : {
      e.L (s.Index s.Multiplier) e.R
        , <SumUpExps
            e.L <MapCall Revert (MulExp s.Multiplier) e.Exps> e.R
          > : {
          (const 0) = /* empty */; /* block collapsed */

          e.ReplacedExps (const s.Number)
            , <QuickSort IsLess-Exp e.ReplacedExps> : e.SortedExps
            = (t.BlockConst e.SortedExps (const s.Number));
        };

      e.Other = (t.BlockConst e.OldExps);
    };
}

/*
  <MulExp t.Exp s.NUMBER> == t.Exp
*/
MulExp {
  (s.Index s.OldMultiplier) s.Multiplier
    = (s.Index <Mul s.OldMultiplier s.Multiplier>);
}

/*
  <SumUpExps e.Exps> == e.Exps
*/
SumUpExps {
  /* Note the first exponent is added to the second, not vice versa. This is
     guaranteed to keep a constant exponent in last place. */
  e.L (s.Index s.Multiplier1) e.M (s.Index s.Multiplier2) e.R
    = <SumUpExps e.L e.M (s.Index <Add s.Multiplier1 s.Multiplier2>) e.R>;

  e.Other = e.Other;
}

/*
  <IsLess-Exp t.Exp1 t.Exp2>
    == True
    == False
*/
IsLess-Exp {
  (s.Index1 s.Multiplier1) (s.Index2 s.Multiplier2)
    , <Explode s.Index1> : s.Char1 e.Digits1
    , <Explode s.Index2> : s.Char2 e.Digits2
    , <Compare <Numb e.Digits1> <Numb e.Digits2>> : {
      '-' = True;

      s.Other = False;
    };
}

/*
  <QuickSort s.IsLess e.List> == e.SortedList

  s.IsLess is a function name.
*/
QuickSort {
  s.IsLess e.List
    , e.List : {
      /* empty list */ = /* empty */;
      
      t.Pivot e.Tail
        , <Partition s.IsLess (/* empty */) t.Pivot (/* empty */) e.Tail>
        : (e.Left) t.Pivot (e.Right)
        = <QuickSort s.IsLess e.Left> t.Pivot <QuickSort s.IsLess e.Right>;
    };
}
 
/*
  <Partition s.IsLess (e.Left) t.Pivot (e.Right) e.List>
    == (e.NewLeft) t.Pivot (e.NewRight)
*/
Partition {
  s.IsLess (e.Left) t.Pivot (e.Right) e.List
    , e.List : {
      /* empty list */ = (e.Left) t.Pivot (e.Right);
      
      t.X e.Tail 
        , <Mu s.IsLess t.X t.Pivot> : {
          True = <Partition s.IsLess (e.Left t.X) t.Pivot (e.Right) e.Tail>;

          False = <Partition s.IsLess (e.Left) t.Pivot (e.Right t.X) e.Tail>;
        };
    };
}

/*
  <ReplaceRepeatedConds (e.Conds) (e.Substs)>
    == (e.UniqueConds) (e.Substs)
*/
ReplaceRepeatedConds {
  (e.Conds) (e.Substs)
    , e.Conds : {
      e.L (t.Const1 is t.Block) e.M (t.Const2 is t.Block) e.R
        = <ReplaceRepeatedConds
            (e.L (t.Const1 is t.Block) e.M e.R)
            (e.Substs <GenSubst (t.Const2) (t.Const1)>)
          >;

      e.Other = (e.Conds) (e.Substs);
    };
}

/*
  An equation is called normal if it has no equal prefixes of suffixes,
  redundant constraints or conditions.

  <NormalizeEq t.Eq> == t.NormalEq
*/
NormalizeEq {
  ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    , <MapCompose
        (<MapCall Curry (Wrap TrimEq (e.Conds)) Left Right>)
        (e.LHS) (e.RHS)
      > : (e.NormalLHS) (e.NormalRHS)
    , <MapCompose
        ((GetConsts (e.NormalLHS)) (GetConsts (e.NormalRHS)))
        (/* no consts at start */)
      > : (e.Consts)
    , <RemoveRedundantConds
        (e.Consts) (e.Conds) (/* empty */)
      > : e.NormalConds
    , <RemoveRedundantRestrictions
        (e.Consts) (e.NormalConds) (e.Constrs) (/* empty */)
      > : e.NormalConstrs
    = ((AreEqual (e.NormalLHS) (e.NormalRHS)) (e.NormalConstrs) (e.NormalConds));
}

/*
  <TrimEq (e.Conds) s.Mode (e.LHS) (e.RHS)> == (e.NewLHS) (e.NewRHS)

  s.Mode ::= Left | Right
*/
TrimEq {
  (e.Conds) s.Mode (e.LHS) (e.RHS)
    , <MapCall Curry (Take s.Mode) (e.LHS) (e.RHS)> : {
      (t.Elem1 e.NewLHS) (t.Elem2 e.NewRHS)
        , <AreEqual t.Elem1 t.Elem2> : {
          True = <TrimEq (e.Conds) s.Mode (e.NewLHS) (e.NewRHS)>;

          False = (e.LHS) (e.RHS);
        };

      e.Other = (e.LHS) (e.RHS);
    };
}

/*
  A condition is redundant if:
  - a constant in its left half is missing from the equation;
  - the condition has the pair type, all constants in its right half are
    missing from the equation and they are not left halfs of some conditions.
*/

/*
  <RemoveRedundantConds (e.Consts) (e.Const) (e.ProcessedConds)>
    == e.ProcessedConds
*/
RemoveRedundantConds {
  (e.Consts) (e.Conds) (e.ProcessedConds)
    , e.Conds : {
      t.Cond e.RestConds 
        , (RemoveRedundantConds
            (e.Consts) (e.RestConds) (e.ProcessedConds)
          ) : t.RemoveCall
        , (RemoveRedundantConds
            (e.Consts) (e.RestConds) (e.ProcessedConds t.Cond)
          ) : t.SkipCall
        , t.Cond : (t.Const is e.Details)
        , <IsElemInSet t.Const (e.Consts)> : {
          True
            , e.Details : {
              (t.Const1 (const 1)) (t.Const2 (const 1))
                , <IsRedundantPairCond
                    (e.Consts) (e.ProcessedConds e.RestConds)
                    t.Const1 t.Const2
                  > : {
                    True = <UnwrapCalls t.RemoveCall>;

                    False = <UnwrapCalls t.SkipCall>;
                  };

              t.Block = <UnwrapCalls t.SkipCall>;
            };

          False = <UnwrapCalls t.RemoveCall>;
        };

      /* empty */ = e.ProcessedConds;
    };
}

/*
  <IsRedundantPairCond (e.Consts) (e.Conds) t.Const1 t.Const2>
    == True
    == False
*/
IsRedundantPairCond {
  (e.Consts) (e.Conds) t.Const1 t.Const2
    , <IntersectSets
        (t.Const1 t.Const2) (e.Consts) (/* empty at start */)
      > : {
      (/* empty */)
        , <MapCall-Till
            (/* empty */) Revert (GetCond (e.Conds))
            t.Const1 t.Const2
          > : {
            /* empty */ = True;

            e.SomeConds = False;
        };

      (e.SomeConsts) = False;
    };
}

/*
  <IntersectSets t.Set1 t.Set2 t.Intersection> == t.Set
*/
IntersectSets {
  (e.L1 t.Elem e.R1) (e.L2 t.Elem e.R2) (e.Intersection)
    = <IntersectSets (e.L1 e.R1) (e.L2 e.R2) (e.Intersection t.Elem)>;

  t.Set1 t.Set2 t.Intersection = t.Intersection;
}

/*
  Returns a condition for t.Const or ε, if the condition isn't found.
  
  <GetCond t.Const (e.Conds)>
    == t.Cond
    == ε
*/
GetCond {
  t.Const (e.Conds)
    , e.Conds : {
      e.L (t.Const is e.Details) e.R = (t.Const is e.Details);

      e.Other = /* empty */;
    };
}

/* я устал... */

/*
  <GetUniqueValues s.Mode e.Expr>
    == e.UniqueExpr
*/
GetUniqueValues {
  Flat e.U1 t.X e.U2 t.X e.U3 = <GetUniqueValues Flat e.U1 t.X e.U2 e.U3>;
  
  Wrap (e.U1 t.X e.U2 t.X e.U3) = <GetUniqueValues Wrap (e.U1 t.X e.U2 e.U3)>;
  
  s.AnyMode e.AlreadyUnique = e.AlreadyUnique;
}

/*
  <IsEmpty e.Any>
    == True
    == False
*/
IsEmpty {
  /* EMPTY */ = True;

  e.Other = False;
}

/* Throws `Recognition Impossible` if the lists have not equal lengths. */
Zip {
  (t.X e.X) (t.Y e.Y) = (t.X t.Y) <Zip (e.X) (e.Y)>;
    
  (/* EMPTY */) (/* EMPTY */) = /* EMPTY */;
}

/*
  Concatenation of corresponding elements of two lists of equal length.
  
  <Overlap ((e.X) e.Xs) ((e.Y) e.Ys)>
    == ((e.X e.Y) e.Rest)
*/
Overlap {
  ((e.X) e.Xs) ((e.Y) e.Ys) = <Overlap (e.Xs (e.X e.Y)) (e.Ys)>;
    
  (e.OverlappedLists) (/* EMPTY */) = (e.OverlappedLists);
}

$ENTRY FormPair {
  t.First t.Second = (t.First t.Second);
}

Trim {
  e.X ' ' e.Y = e.X <Trim e.Y>;
  
  e.Z = e.Z;
}

Arrange {
  Normal (e.1) (e.2) = e.1 e.2;
  
  Inverse (e.1) (e.2) = e.2 e.1;
}

Take {
  Left (t.Term e.Expr) = (t.Term e.Expr);
  
  Right (e.Expr t.Term) = (t.Term e.Expr);
  
  s.AnyMode (/* No term */) = (/* EMPTY */);
}

Unwrap {
  (e.Preamble) (e.Preamble e.Val) = e.Val;
  
  (e.Preamble) e.Preamble e.Val = e.Val;
  
  (e.Preamble) e.Val = e.Val;
}

/*

Currently there is another function called Wrap!

Wrap {
  Plain s.Order (e.Preamble) e.Val
    = <Arrange s.Order (e.Preamble) (e.Val)>;
    
  Inner s.Order (e.Preamble) e.Val
    = (<Arrange s.Order (e.Preamble) (e.Val)>);
    
  Combined s.Order (e.Preamble) e.Val
    = <Arrange s.Order (e.Preamble) ((e.Val))>;
}
*/

/*
  <IsWordInAlphabet (e.Word) (e.Alphabet)>
    == True
    == False
*/
IsWordInAlphabet {
  (e.Word) (e.Alphabet)
    , e.Word : {
      t.Char e.RestWord
        , e.Alphabet : {
          e.L t.Char e.R = <IsWordInAlphabet (e.RestWord) (e.Alphabet)>;

          e.Other = False;
        };

      /* Let's assume an empty word belongs to any alphabet */
      /* EMPTY */ = True;
    };
}

LatinCapitalChars {
  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
}

StructParens {
  e.Arg = <ExtractRealParens Plain e.Arg>; 
}

ExtractRealParens {
  Plain e.x'('e.y')'e.z
    , e.y : {
      e.y1'('e.y2
        , <ExtractRealParens Left () e.y2> : {
          (/* empty */) e.v2
            = <ExtractRealParens Plain e.x '(' e.y1 (e.v2) e.z>;
    
          (e.v1 '(') e.v2
            = <ExtractRealParens Plain e.x '(' e.y1 '(' e.v1 (e.v2) e.z>;
        };
  
      e.other = <ExtractRealParens Plain e.x (e.y) e.z>;
    };

  Left (e.drop) e.y
    , e.y : {
      e.y1 '(' e.y2
        = <ExtractRealParens Left (e.drop e.y1 '(') e.y2>;

      e.z = (e.drop) e.y;
    };
  
  Plain e.Rest = e.Rest;
}

/*
  <ChooseMax s.Val1 s.Val2> == s.MaxVal
*/
ChooseMax {
  s.Val1 s.Val2
    , <Compare s.Val1 s.Val2> : {
      '+' = s.Val1;
      
      s.Any = s.Val2;
    };
}

VarAlphabet {
  = <MapCall
      Plain
      GenVar
      <LatinCapitalChars>
    >;
}

/*
  Returns the First-elements of the constant.

  <GetFirst t.Const (e.Conds)>
    == e.FirstElems
*/
GetFirst {
  t.Const (e.Conds)
    , e.Conds : {
      e.L (t.Const is (t.FirstElem e.Details) e.Elems) e.R
        = t.FirstElem <GetFirst t.FirstElem (e.L e.R)>;

      /* No condition for the constant. */
      e.Conds = /* EMTPY */;
    };
}

/*
  Returns the Last-elements of the constant.

  <GetLast t.Const (e.Conds)>
    == e.LastElems
*/
GetLast {
  t.Const (e.Conds)
    , e.Conds : {
      e.L (t.Const is e.Elems (t.LastElem e.Details)) e.R
        = t.LastElem <GetLast t.LastElem (e.L e.R)>;
      
      /* No condition for the constant. */
      e.Conds = /* EMPTY */;
    };
}

/*
  <GenSubstDenial t.ElementarySubst>
    == t.Restriction
*/
GenSubstDenial {
  (assign (t.Var) (e.NewValue))
    , e.NewValue : {
      t.Var t.Const = (not t.Const ends t.Var);

      t.Const t.Var = (not t.Const starts t.Var);

      /* EMPTY */ = (not empty t.Var);
    };
}

/*
  <CartesianProductOfOptionSets e.OptionSets>
    == (e.MultipliedOptions)
*/
CartesianProductOfOptionSets {
  (e.Set1) (e.Set2) e.RestSets
    = <CartesianProductOfOptionSets 
        <CartesianProduct Overlap (e.Set1) (e.Set2)> e.RestSets
      >;

  (e.Set) = (e.Set);

  /* No sets */ = (/* EMPTY */);
}

/*
  Cartesian product of two arbitary sets with custom pair processing function.
  
  <CartesianProduct s.ProcessingFunction (e.Set1) (e.Set2)>
    == (e.MultipliedElements)
*/
CartesianProduct {
  s.ProcessingFunction (e.Set1) (e.Set2)
    = (<MapCall
        Curry
        (CartesianProduct-Aux s.ProcessingFunction (e.Set2))
        e.Set1
      >);
}

CartesianProduct-Aux {
  s.ProcessingFunction (e.Set) t.Elem
    = <MapCall Curry (s.ProcessingFunction t.Elem) e.Set>;
}

/*
  <RemoveRedundantRestrictions
    (e.EqConsts) (e.Conds) (e.UncheckedConstrs) (e.CheckedConstrs)
  >
    == e.CheckedConstrs
*/
RemoveRedundantRestrictions {
  (e.EqConsts) (e.Conds) (e.UncheckedConstrs) (e.CheckedConstrs)
    , e.UncheckedConstrs : {
      t.Constr e.RestConstrs
        , t.Constr : {
          /* Skipping constraints on emptiness. */
          (OR (not empty t.Var))
            = <RemoveRedundantRestrictions
                (e.EqConsts) (e.Conds) (e.RestConstrs)
                (e.CheckedConstrs t.Constr)
              >;
              
          /* Handling prefix (suffix) restrictions */ 
          (OR t.Restr1 e.AnotherRestr)
            , <IsRestrictionRedundant
                t.Restr1 (e.EqConsts) (e.Conds)
              > : {
              True
                , e.AnotherRestr : {
                  /* EMPTY */ /* removing the disjunct */
                    = <RemoveRedundantRestrictions
                        (e.EqConsts) (e.Conds) (e.RestConstrs)
                        (e.CheckedConstrs)
                      >;

                  t.Restr2
                    , <IsRestrictionRedundant
                        t.Restr2 (e.EqConsts) (e.Conds)
                      > : {
                      True /* removing the disjunct */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conds) (e.RestConstrs)
                            (e.CheckedConstrs)
                          >;
                      
                      False /* removing the first restriction */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conds) (e.RestConstrs)
                            (e.CheckedConstrs (OR t.Restr2))
                          >;
                    };
                };

              False
                , e.AnotherRestr : {
                  /* EMPTY */
                    /* Saving the constraint */
                    = <RemoveRedundantRestrictions
                        (e.EqConsts) (e.Conds) (e.RestConstrs)
                        (e.CheckedConstrs t.Constr)
                      >;

                  t.Restr2
                    , <IsRestrictionRedundant
                        t.Restr2 (e.EqConsts) (e.Conds)
                      > : {
                      True
                        /* Removing the second restriction. */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conds) (e.RestConstrs)
                            (e.CheckedConstrs (OR t.Restr1))
                          >;

                      False
                        /* Saving the constraint */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conds) (e.RestConstrs)
                            (e.CheckedConstrs t.Constr)
                          >;
                    };
                };
            };
        
        };
        
      /* EMPTY */ = e.CheckedConstrs;
    };
}

/*
  Accepts only the prefix and suffix restrictions.

  <IsRestrictionRedundant t.Restr (e.EqConsts) (e.Conds)>
    == True
    == False
*/
IsRestrictionRedundant {
  /* s.Action ::= starts | ends */
  (not t.Const s.Action t.Var) (e.EqConsts) (e.Conds)
    , <IsElemInSet t.Const (e.EqConsts)> : {
      /* The constant is used in the equation. */
      True = False;
      
      False
        , e.Conds : {
          /* At least one condition has the constant in the right half. */
          e.L (t.DefConst is e.L1 (t.Const e.Details) e.R1) e.R = False;
            
          /* The restriction is redundant. */
          e.Other = True; 
        };
    };
}

/*
  Относительно данной константы A будем называть рестрикцию X != BX зависимой,
  если B принадлежит множеству First(A), и независимой в противном случае.
  
  <IsDependentConstr (e.Conds) t.Const t.Constr>
    == True
    == False
*/
IsDependentConstr {
  (e.Conds) t.Const t.Constr
    , t.Constr : {
      (OR (not t.PrefixConst starts t.Var))
        = <IsElemInSet
            t.PrefixConst
            (t.Const <GetFirst t.Const (e.Conds)>)
          >;

      (OR (not t.SuffixConst ends t.Var))
        = <IsElemInSet
            t.SuffixConst
            (t.Const <GetLast t.Const (e.Conds)>)
          >;
    };
}

SelectConstrs {
  (e.Constrs) s.Mode t.Var
    , s.Mode : {
      Prefix
        , e.Constrs : e.L (OR (not t.PrefixConst starts t.Var)) e.R
        = (OR (not t.PrefixConst starts t.Var))
          <SelectConstrs (e.R) s.Mode t.Var>;
      
      Suffix
        , e.Constrs : e.L (OR (not t.SuffixConst ends t.Var)) e.R
        = (OR (not t.SuffixConst ends t.Var))
          <SelectConstrs (e.R) s.Mode t.Var>;

      Empty
        , e.Constrs : e.L (OR (not empty t.Var)) e.R
        = (OR (not empty t.Var));

      s.AnyMode = /* empty */;
    };
}

/*
  <GetNewIndex t.Index>
    == t.NewIndex
*/
GetNewIndex {
  s.OldIndex
    , <Explode s.OldIndex> : s.Char s.FirstDigit e.Digits
    , <Symb <Add <Numb s.FirstDigit e.Digits> 1>> : e.NewNumber
    = <Implode s.Char e.NewNumber>;
}

/*
  <GetNewConst t.Const>
    == t.NextConst
*/
GetNewConst {
  (s.Char s.Number)
    , <LatinCapitalChars> : {
      e.U1 s.Char s.NextChar e.U2 = (s.NextChar s.Number);

      s.FirstChar e.U s.Char = (s.FirstChar <Add s.Number 1>);
    };
}

GenPrefixConstr {
  t.Var t.Const = (OR (not t.Const starts t.Var)) 
}

GenSuffixConstr {
  t.Var t.Const = (OR (not t.Const ends t.Var)) 
}

GenEmptyConstr {
  t.Var = (OR (not empty t.Var)) 
}

GenVar {
  s.Name = (Var s.Name);
}

/*
  <PairComp t.ReplacingConst t.Const1 t.Const2 t.Equation>
    == t.NewReplacingConst (e.Equations)
*/
$ENTRY PairComp {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    = <GetNewConst t.ReplacingConst>
      (
        <HandleEmptySubsts
          t.ReplacingConst t.Const1 t.Const2 t.Equation
        >
      );
}

/*
  If an essentially empty substitution is possible, recursively calls itself
  with an applied and not applied substitution equations. Otherwise, transfers
  control to the `HandleNonEmptySubsts` function.
  
  <HandleEmptySubst
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    /* Calling `GetEmptySubst` is quite expensive, so here's
       used `MapCall-Till` not to make redundant calculations with `MapCall` */
    , <MapCall-Till
        (/* EMPTY */)
        Curry
        (
          GetEmptySubst
          t.Const1 t.Const2 (e.Constrs)
        )
        (e.LHS) (e.RHS)
      >
    : {
      /* Found an essentially empty substitution */
      t.Subst
        = /* Calling with performed substitution */
          <HandleEmptySubsts 
            t.ReplacingConst t.Const1 t.Const2
            (
              (
                AreEqual
                <MapCall Curry (Subst (t.Subst)) (e.LHS) (e.RHS)>
              )
              (e.Constrs)
              (e.Conds)
            )
          >
          /* Calling with not performed substitution */
          <HandleEmptySubsts
            t.ReplacingConst t.Const1 t.Const2
            (
              (AreEqual (e.LHS) (e.RHS))
              (e.Constrs (OR <GenSubstDenial t.Subst>))
              (e.Conds)
            )
          >;
      
      /* No essentially empty substitution is found. */
      /* EMPTY */
        = <HandleNonEmptySubsts
            t.ReplacingConst t.Const1 t.Const2 t.Equation
          >;
    };
}

/*
  Returns any essentially empty substitution possible in the given equation
  half. If no such substitution is found, returns ε.
  
  <GetEmptySubst
    t.Const1 t.Const2 (e.Constrs) (e.EquationHalf)
  >
    == t.Subst
    == ε
*/
GetEmptySubst {
  t.Const1 t.Const2 (e.Constrs) (e.EquationHalf)
    /* Saving the result of frequently called functions */
    , <VarAlphabet> : e.Vars
    , <GetNonEmptyVars e.Constrs> : e.NonEmptyVars
    , e.EquationHalf : {
      e.L t.Const1 e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            (e.Vars)
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;
        
      e.L t.Const1 e.M (Var s.X) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;

      e.L (Var s.X) e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;

      e.L (Var s.X) e.M  (Var s.Y) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X) (Var s.Y))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;
        
      /* No essentially empty substitutions for this half of the equation */
      e.Other = /* EMPTY */;
    };
}

/* Finds and applies essentially non-empty substitutions to the equation. 
  
  <HandleNonEmptySubsts
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleNonEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    , <GetNonEmptySubsts /* substitutions for the right half */
        t.Const1 t.Const2 (e.Constrs) (e.Conds)
        <GetNonEmptySubsts /* substitutions for the left half */
          t.Const1 t.Const2 (e.Constrs) (e.Conds)
          (/* No discovered elementary substitutions at start */)
          (/* No discovered composite substitutions at start */)
          (e.LHS)
        >
        (e.RHS)
      > : (e.ElementarySubsts) (e.CompositeSubsts)
    , <CartesianProductOfOptionSets
        <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
      >
    : (e.MultipliedOptions) /* what if no options initially? */
    , <MapCall
        Curry
        (ProcessOption (e.Conds))
        e.MultipliedOptions
      > : {
      /* No implicit occurences. Applying empty option to the equation. */
      /* EMPTY */
        = <ApplyOption
            t.ReplacingConst t.Const1 t.Const2 t.Equation
            ((/* No substitutions */)(/* No constraints */))
          >;

      e.ProcessedOptions
        = <MapCall
            Curry
            (ApplyOption t.ReplacingConst t.Const1 t.Const2 t.Equation)
            e.ProcessedOptions
          >;
    };
}

/*
  Returns essentially non-empty substitutions for the given equation half.
  There are no impossible substitutions among returned.
  
  <GetNonEmptySubst
    t.Const1 t.Const2 (e.Constrs) (e.Conds)
    (e.DiscoveredElementarySubsts) (e.DiscoveredCompositeSubsts) (e.Elems)
  >
    == e.Substs
*/
GetNonEmptySubsts {
  t.Const1 t.Const2 (e.Constrs) (e.Conds)
  (e.ElementarySubsts) (e.CompositeSubsts) (e.Elems)
    , e.Elems : {
      (Var s.X) (Var s.Y) e.RestElems
        , <GenSubst ((Var s.X)) ((Var s.X) t.Const1)> : t.Subst1
        , <GenSubst ((Var s.Y)) (t.Const2 (Var s.Y))> : t.Subst2
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constrs) (e.Conds)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.Y) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constrs) (e.Conds)
            (e.ElementarySubsts) (e.CompositeSubsts (t.Subst1 t.Subst2))
            ((Var s.Y) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet (t.Subst1 t.Subst2) (e.CompositeSubsts)> : {
            /* The substitution is already processed. */
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constrs : {
                e.L (OR (not t.ConstX ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.ConstX
                      (t.Const1 <GetLast t.Const1 (e.Conds)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False
                        ,  e.L e.R : {
                          e.L1 (OR (not t.ConstY starts (Var s.Y))) e.R1
                            , <IsElemInSet
                                t.ConstY
                                (t.Const2 <GetFirst t.Const2 (e.Conds)>)
                              > : {
                                /* The substitution is impossible. */
                                True = <UnwrapCalls t.SkipSubst>;

                                False = <UnwrapCalls t.AddSubst>;
                              };
                          
                          /* No constraint on the substitution. */
                          e.L e.R = <UnwrapCalls t.AddSubst>;
                        };
                    };

                /* No constraint on the first substitution. */
                e.L (OR (not t.ConstY starts (Var s.Y))) e.R
                  , <IsElemInSet
                      t.ConstY
                      (t.Const2 <GetFirst t.Const2 (e.Conds)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;

                      False = <UnwrapCalls t.AddSubst>;
                    };

                /* No constraints on the substitutions. */
                e.Constrs = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Const1 (Var s.X) e.RestElems
        , <GenSubst ((Var s.X)) (t.Const2 (Var s.X))> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constrs) (e.Conds)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constrs) (e.Conds)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constrs : {
                e.L (OR (not t.Const starts (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const2 <GetFirst t.Const2 (e.Conds)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constrs = <UnwrapCalls t.AddSubst>;
              };
        };
        
      (Var s.X) t.Const2 e.RestElems
        , <GenSubst ((Var s.X)) ((Var s.X) t.Const1)> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constrs) (e.Conds)
            (e.ElementarySubsts) (e.CompositeSubsts)
            (e.RestElems) /* can skip t.Const2 */
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constrs) (e.Conds)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            (e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constrs : {
                e.L (OR (not t.Const ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const1 <GetLast t.Const1 (e.Conds)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constrs = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Elem1 t.Elem2 e.RestElems
        = <GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constrs) (e.Conds)
            (e.ElementarySubsts) (e.CompositeSubsts)
            (t.Elem2 e.RestElems)
          >;

      e.OneOrNoTerm = (e.ElementarySubsts) (e.CompositeSubsts);
    };
}

/*
  <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
    == e.OptionSets
*/
GenOptionSets {
  (e.ElementarySubsts) (e.CompositeSubsts)
    , <GetUniqueValues
        Flat
        <MapCall
          Revert
          (GetSpecialSubsts (e.ElementarySubsts))
          e.CompositeSubsts
        >
      >
    : e.SpecialSubsts
    , <SubtractSets (e.ElementarySubsts) (e.SpecialSubsts)>
    : (e.UnprocessedElementarySubsts)
    = <MapCall
        Revert
        (GenCompositeOptionSet (e.SpecialSubsts))
        e.CompositeSubsts
      >
      <MapCall
        Plain
        GenElementaryOptionSet
        e.UnprocessedElementarySubsts
      >;
}

/*
  For the equation, we call an essential elementary substitution "special"
  if it is present in some essential composite substitution.

  Returns special substitutions of the given composite substitution.
  
  <GetSpecialSubsts t.CompositeSubst (e.ElementarySubsts)>
    == e.SpecialSubsts
*/
GetSpecialSubsts {
  (t.Subst1 t.Subst2) (e.ElementarySubsts)
    , e.ElementarySubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is special too. */
          e.L1 t.Subst2 e.R1 = t.Subst1 t.Subst2;

          /* Only the first substitution is special. */
          e.Other = t.Subst1;
        };

      /* Only the second substitution is special. */
      e.L t.Subst2 e.R = t.Subst2;

      /* None of the substitutions are special. */
      e.Other = /* EMPTY */;
    };
}

/*
  We will call an option set composite if it is obtained from a composite
  substitution. 
  
  <GenCompositeOptionSet t.CompositeSubst (e.SpecialSubsts)>
    == e.OptionSet
*/
GenCompositeOptionSet {
  (t.Subst1 t.Subst2) (e.SpecialSubsts)
    , e.SpecialSubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is special too. */
          e.L1 t.Subst2 e.R1
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
                (
                  (t.Subst2)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
              );

          /* Only the first substitution is special. */
          e.Other
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                  )
                )
              );
        };

      /* Only the second substitution is special. */
      e.L t.Subst2 e.R
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (t.Subst2)
              (
                (OR <GenSubstDenial t.Subst1>)
              )
            )
            (
              (/* No substitutions */)
              (
                (OR <GenSubstDenial t.Subst2>)
              )
            )
          );

      /* None of the substitutions are special. */     
      e.Other
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (/* No substitutions */)
              (
                (
                  OR
                  <GenSubstDenial t.Subst1>
                  <GenSubstDenial t.Subst2>
                )
              )
            )
          );
    };
}

/*
  We will call an option set elementary if it is obtained from an elementary
  substitution. 
  
  <GenElementaryOptionSet t.ElementarySubst>
    == e.OptionSet
*/
GenElementaryOptionSet {
  t.Subst
    = (
        (
          (t.Subst)
          (/* No constraints */)
        )
        (
          (/* No substitutions */)
          (
            (OR <GenSubstDenial t.Subst>)
          )
        )
      );
}

/*
  Removes duplicates, redundant constraints and checks the option for
  consistency.
  
  <ProcessOption (e.Conds) t.Option>
    == t.ProcessedOption
    == ε
*/
ProcessOption {
  (e.Conds) ((e.Substs) (e.Constrs))
    , <MapCall
        Curry
        (GetUniqueValues Wrap)
        (e.Substs) (e.Constrs)
      > : (e.UniqueSubsts) (e.UniqueConstrs)
    , <RemoveTrivConstrs
        (e.UniqueConstrs)
        (e.Conds)
      > : e.NecessaryConstrs
    = <FixOptionConsistency
        ((e.UniqueSubsts) (e.NecessaryConstrs))
        (/* No checked substitutions at start */)
        (e.Conds)
      >;
}

/*
  Removes trivially performed non-trivial disjuncts.
  
  <RemoveTrivConstrs (e.Constrs) (e.Conds)>
    == e.NecessaryConstrs
*/
RemoveTrivConstrs {
  (e.Constrs) (e.Conds)
    , e.Constrs : {
      e.L (OR (not t.Const1 ends t.VarX) (not t.Const2 starts t.VarY)) e.R
        , e.L e.R : {
          e.L1 (OR (not t.ConstX ends t.VarX)) e.R2
            , <IsElemInSet t.ConstX
                (t.Const1 <GetLast t.Const1 (e.Conds)>)
              > : True /* found stronger restriction */
            = e.L <RemoveTrivConstrs (e.R) (e.Conds)>;
                
          e.L1 (OR (not t.ConstY starts t.VarY)) e.R2
            , <IsElemInSet
                t.ConstY
                (t.Const2 <GetFirst t.Const2 (e.Conds)>)
              > : True
            = e.L <RemoveTrivConstrs (e.R) (e.Conds)>;

          e.L e.R /* cannot say whether the disjunct is redundant or not */
            = e.L (OR (not t.Const1 ends t.VarX) (not t.Const2 starts t.VarY))
              <RemoveTrivConstrs (e.R) (e.Conds)>;
        };
        
      e.TrivDisjuncts = e.TrivDisjuncts;
    };
}

/*
  Checks an option for consistency and fixes avoidable contradictions
  whenever necessary. If an unavoidable contradiction is found, returns ε.
  Otherwise, returns the processed option.
  
  <FixOptionConsistency t.Option (e.CheckedSubsts) (e.Conds)>
    == t.FixedOption
    == ε
*/
FixOptionConsistency {
  ((e.UncheckedSubsts) (e.Constrs)) (e.CheckedSubsts) (e.Conds)
    , e.UncheckedSubsts : {
      (assign (t.Var) (t.Var t.Const)) e.RestSubsts /* suffix substitution */
      , e.Constrs : {
        e.L (OR (not t.RestrConst ends t.Var) e.AnotherRestr) e.R
          , <IsElemInSet
              t.RestrConst
              (t.Const <GetLast t.Const (e.Conds)>)
            > : True
          , e.AnotherRestr : {
            /* EMPTY */ = /* EMPTY */; /* unavoidable contradiction */

            t.Restr /* force another restriction to be executed */
              = <FixOptionConsistency
                  ((e.UncheckedSubsts) (e.L (OR t.Restr) e.R))
                  (e.CheckedSubsts) (e.Conds)
                >;
          };
        
        /* No constraints on the substitution. */
        e.CheckedConstrs
          = <FixOptionConsistency
              ((e.RestSubsts) (e.CheckedConstrs))
              (e.CheckedSubsts (assign (t.Var) (t.Var t.Const)))
              (e.Conds)
            >;
      };

      (assign (t.Var) (t.Const t.Var)) e.RestSubsts /* prefix substitution */
        , e.Constrs : {
          e.L (OR e.AnotherRestr (not t.RestrConst starts t.Var)) e.R
            , <IsElemInSet
                t.RestrConst
                (t.Const <GetFirst t.Const (e.Conds)>)
              > : True
            , e.AnotherRestr : {
              /* EMPTY */ = /* EMPTY */;

              t.Restr
                = <FixOptionConsistency
                    ((e.UncheckedSubsts) (e.L (OR t.Restr) e.R))
                    (e.CheckedSubsts) (e.Conds)
                  >;
            };

          e.CheckedConstrs
            = <FixOptionConsistency
                ((e.RestSubsts) (e.CheckedConstrs))
                (e.CheckedSubsts (assign (t.Var) (t.Const t.Var)))
                (e.Conds)
              >;
        };
        
      /* All the substitutions are checked. */
      /* EMPTY */ = ((e.CheckedSubsts) (e.Constrs));
    };
}

/*
  Applies option substitutions to the equation (also adds corresponding index
  equation) and appends the option constraints to the equation constraints.
  Thereafter trimmes this equation, removes redundant elements and modifies
  constraints.
  
  <ApplyOption t.ReplacingConst t.Const1 t.Const2 t.Equation t.Option>
    == t.NewEquation
*/
ApplyOption {
  t.ReplacingConst t.Const1 t.Const2
  ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
  ((e.Substs) (e.NewConstrs))
    , <MapCall /* replacing the pairs with the new const */
        Curry
        (Subst (<GenSubst (t.Const1 t.Const2) (t.ReplacingConst)>))
        <MapCall /* applying the option substitutions */
          Curry
          (Subst (e.Substs))
          (e.LHS) (e.RHS)
        >
      > : (e.SubstLHS) (e.SubstRHS)
      
    , <MapCompose
        (<MapCall Curry (Wrap TrimEq (e.Conds)) Left Right>)
        (e.SubstLHS) (e.SubstRHS)
      > : (e.TrimmedLHS) (e.TrimmedRHS)
    , <MapCompose
        ((GetConsts (e.TrimmedLHS)) (GetConsts (e.TrimmedRHS)))
        (/* no consts at start */)
      > : (e.EqConsts)
    , <RemoveRedundantConds
        (e.EqConsts)
        (
          e.Conds
          (t.ReplacingConst is (t.Const1 (const 1)) (t.Const2 (const 1)))
        )
        (/* EMPTY */)
      > : e.NecessaryConds 
    , <RemoveRedundantRestrictions
        (e.EqConsts) (e.NecessaryConds) (e.Constrs) (/* EMPTY */)
      > : e.NecessaryConstrs
    , <ModifyRestrictions
        (e.Substs) (e.NecessaryConstrs e.NewConstrs)
        (e.NecessaryConds)
      > : e.ModifiedConstrs
    =
      (
        (AreEqual (e.TrimmedLHS) (e.TrimmedRHS))
        (e.ModifiedConstrs) (e.NecessaryConds)
      );
}

/*
  TODO: fix the cycling

  Modifies constraints taking into account the substitutions.
  
  <ModifyRestrictions (e.Substs) (e.Constrs) (e.Conds)>
    == e.ModifiedConstrs
*/
ModifyRestrictions {
  (e.Substs) (e.Constrs) (e.Conds)
    , e.Substs : {
      (assign (t.Var) (t.Const t.Var)) e.RestSubsts
        , e.Constrs : { /* the order of the rules is important here */
          e.L (OR (not empty t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conds)>;

          /* Thanks to the GetNonEmptySubsts the t.PrefixConst is definitely
             not in the First(t.Const) set. */
          e.L (OR (not t.PrefixConst starts t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conds)>;

          e.L (OR t.SuffixRestr (not t.PrefixConst starts t.Var)) e.R
            , <IsElemInSet
                t.PrefixConst
                (<GetFirst t.Const (e.Conds)>)
              > : {
              True /* forcing the suffix restriction to be executed */
                = <ModifyRestrictions
                    (e.RestSubsts) /* pay attention that we're moving on */
                    (e.L (OR t.SuffixRestr) e.R) (e.Conds)
                  >;

              False /* cannot say anything definite, moving on */
                = <ModifyRestrictions
                    (e.RestSubsts) (e.Constrs) (e.Conds)
                  >;
            };

          e.Other /* moving on */
            = <ModifyRestrictions
                (e.RestSubsts) (e.Constrs) (e.Conds)
              >;
        };
      
      (assign (t.Var) (t.Var t.Const)) e.RestSubsts
        , e.Constrs : {
          e.L (OR (not empty t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conds)>;
            
          e.L (OR (not t.SuffixConst ends t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conds)>;

          e.L (OR (not t.SuffixConst ends t.Var) t.PrefixRestr) e.R
            , <IsElemInSet
                t.SuffixConst
                (<GetLast t.Const (e.Conds)>)
              > : {
              True
                = <ModifyRestrictions
                    (e.RestSubsts) (e.L (OR t.PrefixRestr) e.R) (e.Conds)
                  >;

              False
                = <ModifyRestrictions
                    (e.RestSubsts) (e.Constrs) (e.Conds)
                  >;
            };

          e.Other
            = <ModifyRestrictions
                (e.RestSubsts) (e.Constrs) (e.Conds)
              >;
        };
        
      /* EMPTY */ = e.Constrs;
    };
}

/*
  <BlockComp t.BlockConst t.Const s.Index t.Eq>
    == (t.NewConst t.NewIndex t.NewEq)+
*/
$ENTRY BlockComp {
  t.BlockConst t.Const s.Index t.Eq
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    , <MapCompose
        (<MapCall Curry (Wrap GetVars) (e.LHS) (e.RHS)>) (/* empty */)
      > : (e.EqVars)
    , <MapCall
        Curry
        (GenBlockOptionSets (e.Constrs) (e.Conds) t.BlockConst)
        e.EqVars
      > : e.OptionSets
    , <CartesianProductOfOptionSets e.OptionSets> : (e.MultipliedOptions)
    = <MapCall
        Curry
        (ApplyBlockOption t.BlockConst t.Const s.Index t.Eq)
        e.MultipliedOptions
      >;
}

/*
  <ApplyBlockOption t.BlockConst t.Const s.Index t.Eq t.BlockOption>
    == (t.NewConst t.NewIndex t.NewEq)
*/
ApplyBlockOption {
  t.BlockConst t.Const s.Index t.Eq t.Option
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    , t.Option : ((e.Substs) (e.AddedConstrs) (e.ExcludedConstrs))
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.LHS) (e.RHS)
      > : (e.SubstLHS) (e.SubstRHS)
    , <MapCall
        Curry
        (JoinBlocks t.BlockConst)
        (e.SubstLHS) (e.SubstRHS)
      > : (e.JoinedLHS) (e.JoinedRHS)
    , <MapCall-Compose
        (NameBlocks t.BlockConst (/* no processed elems at start */))
        (t.Const s.Index (e.Conds))
        (e.JoinedLHS) (e.JoinedRHS)
      > : (e.NewLHS) (e.NewRHS) t.NewConst s.NewIndex (e.NewConds)
    , <SubtractSets
        (e.Constrs e.AddedConstrs) (e.ExcludedConstrs)
      > : (e.NewConstrs)
    /* seems the equation is already normal */
    = (
        t.NewConst s.NewIndex
        ((AreEqual (e.NewLHS) (e.NewRHS)) (e.NewConstrs) (e.NewConds))
      );
}

/*
  Compatible with the MapCall-Compose function.

  <NameBlocks
    t.BlockConst (e.ProcessedElems) ; curried args
    t.Const s.Index (e.Conds)  ; composition args
    (e.Elems)
  > == t.NewConst t.NewIndex (e.NewConds) t.NewElem
*/
NameBlocks {
  t.BlockConst (e.ProcessedElems) t.Const s.Index (e.Conds) (e.Elems)
    , e.Elems : {
      e.L (t.BlockConst e.Indices t.Summand) e.R
        , <NameIndices
            s.Index (e.Indices) (/* no named indices at start */)
          > : s.NewIndex (e.NamedIndices)
        , <MapCall Revert (FormPair 1) e.NamedIndices> : e.Exps
        = <NameBlocks
            t.BlockConst (e.ProcessedElems e.L t.Const)
            <GetNewConst t.Const> s.NewIndex
            (e.Conds (t.Const is (t.BlockConst e.Exps t.Summand)))
            (e.R)
          >;
          
      e.Other = t.Const s.Index (e.Conds) (e.ProcessedElems e.Elems);
    };
}

/*
  <NameIndices s.Index (e.NamelessIndices) (e.NamedIndices)>
    == s.NewIndex (e.NamedIndices)
*/
NameIndices {
  s.Index (e.NamelessIndices) (e.NamedIndices)
    , e.NamelessIndices : {
      Index e.RestIndices
        = <NameIndices
            <GetNewIndex s.Index> (e.RestIndices) (e.NamedIndices s.Index)
          >;

      /* no nameless indices */ = s.Index (e.NamedIndices);
    };
}

/*
  Accepts the block constant and half of the equation. Compresses extracted
  blocks and explicit blocks of length more than two. 
  
  <JoinBlocks t.BlockConst (e.Elems)> == (e.NewElems)
*/
JoinBlocks {
  t.BlockConst (e.Elems)
    , e.Elems : {
      /* assumed nameless indices, i.e. of the form Index */
      e.L t.BlockConst (t.BlockConst e.Indices (const s.Num)) e.R
        = <JoinBlocks
            t.BlockConst
            (e.L (t.BlockConst e.Indices (const <Add s.Num 1>)) e.R)
          >;
          
      e.L (t.BlockConst e.Indices (const s.Num)) t.BlockConst e.R
        = <JoinBlocks
            t.BlockConst
            (e.L (t.BlockConst e.Indices (const <Add s.Num 1>)) e.R)
          >;
          
      e.L (t.BlockConst e.Indices1 (const s.Num1))
      (t.BlockConst e.Indices2 (const s.Num2)) e.R
        = <JoinBlocks
            t.BlockConst
            (
              e.L
              (t.BlockConst e.Indices1 e.Indices2 (const <Add s.Num1 s.Num2>))
              e.R
            )
          >;
      
      e.L t.BlockConst t.BlockConst e.R
        = <JoinBlocks t.BlockConst (e.L (t.BlockConst (const 2)) e.R)>;

      e.Other = (e.Elems);
    };
}

/*
  <GenBlockOptionSets (e.Constrs) (e.Conds) t.BlockConst t.Var>
    == e.OptionSets
*/
GenBlockOptionSets {
  (e.Constrs) (e.Conds) t.BlockConst t.Var
    , <SelectConstrs (e.Constrs) Prefix t.Var> : e.PrefixConstrs
    , <MapCall-Till
        (False) Curry (IsDependentConstr (e.Conds) t.BlockConst)
        e.PrefixConstrs
      > : s.HasDependentPrefixConstrs
    , <SelectConstrs (e.Constrs) Suffix t.Var> : e.SuffixConstrs
    , <MapCall-Till
        (False) Curry (IsDependentConstr (e.Conds) t.BlockConst)
        e.SuffixConstrs
      > : s.HasDependentSuffixConstrs
    , (t.BlockConst Index (const 0)) : t.Block
    , (t.BlockConst Index (const 1)) : t.NonEmptyBlock
    , <SelectConstrs (e.Constrs) Empty t.Var> : {
      /* EMPTY */
        , <IsEmpty e.PrefixConstrs> : {
          True
            , <IsEmpty e.SuffixConstrs> : {
              /* no constraints */
              True
                = (
                    (
                      (<GenSubst (t.Var) (t.Block)>)
                      (/* no added constraints */)
                      (/* no excluded constraints */)
                    )
                    (
                      (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                      (
                        <GenPrefixConstr t.Var t.BlockConst>
                        <GenEmptyConstr t.Var>
                        <GenSuffixConstr t.Var t.BlockConst>
                      )
                      (/* no excluded constraints */)
                    )
                  );

              False
                , s.HasDependentSuffixConstrs : {
                  /* dependent suffix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (/* empty */)>)
                          (/* no added constraints */)
                          (e.SuffixConstrs)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (
                            <GenPrefixConstr t.Var t.BlockConst>
                            <GenEmptyConstr t.Var>
                          )
                          (/* no excluded constraints */)
                        )
                      );

                  /* independent suffix constraints */
                  False
                    = (
                        (
                          (<GenSubst (t.Var) (t.Block)>)
                          (/* no added constraints */)
                          (e.SuffixConstrs)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (
                            <GenPrefixConstr t.Var t.BlockConst>
                            <GenEmptyConstr t.Var>
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstr t.Var t.BlockConst>
                            <GenEmptyConstr t.Var>
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (e.SuffixConstrs)
                        )
                      );
                };
            };
          
          False
            , s.HasDependentPrefixConstrs : {
              True
                , <IsEmpty e.SuffixConstrs> : {
                  /* dependent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (/* empty */)>)
                          (/* no added constraints */)
                          (e.PrefixConstrs)
                        )
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenEmptyConstr t.Var>
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                      );
                  
                  False
                    , s.HasDependentSuffixConstrs : {
                      /* dependent both prefix and suffix constraints */
                      True
                        = (
                            (
                              (<GenSubst (t.Var) (/* empty */)>)
                              (/* no added constraints */)
                              (e.PrefixConstrs e.SuffixConstrs)
                            )
                            (
                              (/* no substitutions */) 
                              (<GenEmptyConstr t.Var>)
                              (/* no excluded constraints */)
                            )
                          );
                          
                      /* dependent prefix, independent suffix constraints */
                      False
                        = (
                            (
                              (<GenSubst (t.Var) (/* empty */)>)
                              (/* no added constraints */)
                              (e.PrefixConstrs e.SuffixConstrs)
                            )
                            (
                              (/* no substitutions */)
                              (
                                <GenEmptyConstr t.Var>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>)
                              (
                                <GenEmptyConstr t.Var>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (e.SuffixConstrs)
                            )
                          );
                    };
                };

              False
                , <IsEmpty e.SuffixConstrs> : {
                  /* independent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.Block)>)
                          (/* no added constraints */)
                          (e.PrefixConstrs)
                        )
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenPrefixConstr t.Var t.BlockConst>
                            <GenEmptyConstr t.Var>
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstr t.Var t.BlockConst>
                            <GenEmptyConstr t.Var>
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (e.PrefixConstrs)
                        )
                      );
                      
                  False
                    , s.HasDependentSuffixConstrs : {
                      /* independent prefix, dependent suffix constraints */
                      True
                        = (
                            (
                              (<GenSubst (t.Var) (/* empty */)>)
                              (/* no added constraints */)
                              (e.PrefixConstrs e.SuffixConstrs)
                            )
                            (
                              (/* no substitutions */)
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenEmptyConstr t.Var>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>)
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenEmptyConstr t.Var>
                              )
                              (e.PrefixConstrs)
                            )
                          );

                      /* independent both prefix and suffix constraints */
                      False
                        = (
                            (
                              (<GenSubst (t.Var) (t.Block)>)
                              (/* no added constraints */)
                              (e.PrefixConstrs e.SuffixConstrs)
                            )
                            (
                              (/* no substitutions */) 
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenEmptyConstr t.Var>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>) 
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenEmptyConstr t.Var>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (e.SuffixConstrs)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>) 
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenEmptyConstr t.Var>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (e.PrefixConstrs)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var t.Block)>) 
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenEmptyConstr t.Var>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (e.PrefixConstrs e.SuffixConstrs)
                            )
                          );
                    };
                };
            };
        };
      
      t.EmptyConstr
        , <IsEmpty e.PrefixConstrs> : {
          True
            , <IsEmpty e.SuffixConstrs> : {
              /* no other constraints */
              True
                = (
                    (
                      (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                      (/* no added constraints */)
                      (t.EmptyConstr)
                    )
                    (
                      (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                      (
                        <GenPrefixConstr t.Var t.BlockConst>
                        <GenSuffixConstr t.Var t.BlockConst>
                      )
                      (/* no excluded constraints */)
                    )
                  );

              False
                , s.HasDependentSuffixConstrs : {
                  /* dependent suffix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (<GenPrefixConstr t.Var t.BlockConst>)
                          (/* no excluded constraints */)
                        )
                      );

                  /* independent suffix constraints */
                  False
                    = (
                        (
                          (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                          (/* no added constraints */)
                          (e.SuffixConstrs t.EmptyConstr)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (
                            <GenPrefixConstr t.Var t.BlockConst>
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstr t.Var t.BlockConst>
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (e.SuffixConstrs)
                        )
                      );
                };
            };
          
          False
            , s.HasDependentPrefixConstrs : {
              True
                , <IsEmpty e.SuffixConstrs> : {
                  /* dependent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                      );
                  
                  False
                    , s.HasDependentSuffixConstrs : {
                      /* dependent both prefix and suffix constraints */
                      True
                        = (
                            (
                              (/* no substitutions */) 
                              (/* no added constraints */)
                              (/* no excluded constraints */)
                            )
                          );
                          
                      /* dependent prefix, independent suffix constraints */
                      False
                        = (
                            (
                              (/* no substitutions */)
                              (<GenSuffixConstr t.Var t.BlockConst>)
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>)
                              (<GenSuffixConstr t.Var t.BlockConst>)
                              (e.SuffixConstrs)
                            )
                          );
                    };
                };

              False
                , <IsEmpty e.SuffixConstrs> : {
                  /* independent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                          (/* no added constraints */)
                          (e.PrefixConstrs t.EmptyConstr)
                        )
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenPrefixConstr t.Var t.BlockConst>
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstr t.Var t.BlockConst>
                            <GenSuffixConstr t.Var t.BlockConst>
                          )
                          (e.PrefixConstrs)
                        )
                      );
                      
                  False
                    , s.HasDependentSuffixConstrs : {
                      /* independent prefix, dependent suffix constraints */
                      True
                        = (
                            (
                              (/* no substitutions */)
                              (<GenPrefixConstr t.Var t.BlockConst>)
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>)
                              (<GenPrefixConstr t.Var t.BlockConst>)
                              (e.PrefixConstrs)
                            )
                          );

                      /* independent both prefix and suffix constraints */
                      False
                        = (
                            (
                              (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                              (/* no added constraints */)
                              (
                                e.PrefixConstrs e.SuffixConstrs
                                t.EmptyConstr
                              )
                            )
                            (
                              (/* no substitutions */) 
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>) 
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (e.SuffixConstrs)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>) 
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (e.PrefixConstrs)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var t.Block)>) 
                              (
                                <GenPrefixConstr t.Var t.BlockConst>
                                <GenSuffixConstr t.Var t.BlockConst>
                              )
                              (e.PrefixConstrs e.SuffixConstrs)
                            )
                          );
                    };
                };
            };
        };
    };
}

