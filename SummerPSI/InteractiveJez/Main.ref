*$INLINE HigherOrder;

/*
  TODO:
  - rewrite Overlap
*/

/*
  DATA STRUCTURES.
  
  t.Equation
    ::= ((AreEqual (t.Element*) (t.Element*)) (t.Constraint*) (t.Condition*))

  t.Element  ::= t.Constant | t.Variable
  t.Constant ::= (s.LETTER s.NUMBER)
  t.Variable ::= (Var s.LETTER)

  t.Constraint ::= (OR t.Restriction+)
  t.Restriction
    ::= (not empty t.Variable) |
        (not t.Constant starts t.Variable) |
        (not t.Constant ends t.Variable)

  t.Condition ::= (t.Constant is t.Factor+)
  t.Factor    ::= (t.Constant t.Exponent* (const s.NUMBER))
  t.Exponent  ::= (s.WORD s.NUMBER)

  e.OptionSet    ::= (t.Option*)
  t.Option       ::= ((t.Substitution*) (t.Constraint*) (t.Constraint*))
  t.Substitution ::= (assign (e.ANY) (e.ANY))

  ABBREVIATIONS.
  
  arg    == argument
  const  == constant
  eq     == equation
  restr  == restriction
  subst  == substitution
  var    == variable
*/

/*
  <GetNewIndex t.Index>
    == t.NewIndex
*/
GetNewIndex {
  s.OldIndex
    , <Explode s.OldIndex> : s.Letter s.FirstDigit e.Digits
    , <Symb <Add <Numb s.FirstDigit e.Digits> 1>> : e.NewNumber
    = <Implode s.Letter e.NewNumber>;
}

/*
  <GetNewConst t.Const>
    == t.NextConst
*/
GetNewConst {
  (s.Letter s.Number)
    , <LatinCapitalLetters> : {
      e.U1 s.Letter s.NextLetter e.U2 = (s.NextLetter s.Number);

      s.FirstLetter e.U s.Letter = (s.FirstLetter <Add s.Number 1>);
    };
}

/*
  <SubtractSets (e.FirstSet) (e.SecondSet)
    == (e.FirstSetWithoutSecond)
*/
SubtractSets {
  (e.U1 t.CommonElement e.U2) (e.V1 t.CommonElement e.V2)
    = <SubtractSets (e.U1 e.U2) (e.V1 e.V2)>;

  /* No common elements */
  t.Reduced t.Subtracted = t.Reduced;
}

/*
  <GetUniqueValues s.Mode e.Expr>
    == e.UniqueExpr
*/
GetUniqueValues {
  Flat e.U1 t.X e.U2 t.X e.U3 = <GetUniqueValues Flat e.U1 t.X e.U2 e.U3>;
  
  Wrap (e.U1 t.X e.U2 t.X e.U3) = <GetUniqueValues Wrap (e.U1 t.X e.U2 e.U3)>;
  
  s.AnyMode e.AlreadyUnique = e.AlreadyUnique;
}

/*
  <IsEmpty e.Any>
    == True
    == False
*/
IsEmpty {
  /* EMPTY */ = True;

  e.Other = False;
}

/*
  <QuickSort s.LessFunc e.List>
    == e.SortedList
*/
QuickSort {
  s.LessFunc e.List
    , e.List : {
      /* Empty list */ = /* EMPTY */;
      
      t.Pivot e.Tail
        , <Partition s.LessFunc () t.Pivot () e.Tail>
        : (e.Left) t.Pivot (e.Right)
        = <QuickSort s.LessFunc e.Left>
          t.Pivot
          <QuickSort s.LessFunc e.Right>;
    };
}
 
/*
  <Partition s.LessFunc (e.Left) t.Pivot (e.Right) e.List>
    == (e.NewLeft) t.Pivot (e.NewRight)
*/
Partition {
  s.LessFunc (e.Left) t.Pivot (e.Right) e.List
    , e.List : {
      /* Empty list */ = (e.Left) t.Pivot (e.Right);
      
      t.X e.Tail 
        , <Mu s.LessFunc t.X t.Pivot> : {
          True = <Partition s.LessFunc (e.Left t.X) t.Pivot (e.Right) e.Tail>;

          False = <Partition s.LessFunc (e.Left) t.Pivot (e.Right t.X) e.Tail>;
        };
    };
}

/* Throws `Recognition Impossible` if the lists have not equal lengths. */
Zip {
  (t.X e.X) (t.Y e.Y) = (t.X t.Y) <Zip (e.X) (e.Y)>;
    
  (/* EMPTY */) (/* EMPTY */) = /* EMPTY */;
}

/*
  Concatenation of corresponding elements of two lists of equal length.
  
  <Overlap ((e.X) e.Xs) ((e.Y) e.Ys)>
    == ((e.X e.Y) e.Rest)
*/
Overlap {
  ((e.X) e.Xs) ((e.Y) e.Ys) = <Overlap (e.Xs (e.X e.Y)) (e.Ys)>;
    
  (e.OverlappedLists) (/* EMPTY */) = (e.OverlappedLists);
}

$ENTRY FormPair {
  t.First t.Second = (t.First t.Second);
}

Trim {
  e.X ' ' e.Y = e.X <Trim e.Y>;
  
  e.Z = e.Z;
}

Arrange {
  Normal (e.1) (e.2) = e.1 e.2;
  
  Inverse (e.1) (e.2) = e.2 e.1;
}

Take {
  Left (t.Term e.Expr) = (t.Term e.Expr);
  
  Right (e.Expr t.Term) = (t.Term e.Expr);
  
  s.AnyMode (/* No term */) = (/* EMPTY */);
}

Unwrap {
  (e.Preamble) (e.Preamble e.Val) = e.Val;
  
  (e.Preamble) e.Preamble e.Val = e.Val;
  
  (e.Preamble) e.Val = e.Val;
}

Wrap {
  Plain s.Order (e.Preamble) e.Val
    = <Arrange s.Order (e.Preamble) (e.Val)>;
    
  Inner s.Order (e.Preamble) e.Val
    = (<Arrange s.Order (e.Preamble) (e.Val)>);
    
  Combined s.Order (e.Preamble) e.Val
    = <Arrange s.Order (e.Preamble) ((e.Val))>;
}

/*
  <IsWordInAlphabet (e.Word) (e.Alphabet)>
    == True
    == False
*/
IsWordInAlphabet {
  (e.Word) (e.Alphabet)
    , e.Word : {
      t.Letter e.RestWord
        , e.Alphabet : {
          e.L t.Letter e.R = <IsWordInAlphabet (e.RestWord) (e.Alphabet)>;

          e.Other = False;
        };

      /* Let's assume an empty word belongs to any alphabet */
      /* EMPTY */ = True;
    };
}

LatinCapitalLetters {
  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
}

/*
  <IsElemInSet t.Elem (e.Set)>
    == True
    == False
*/
IsElemInSet {
  t.Elem (e.Set)
    , e.Set : {
      e.L t.Elem e.R = True;

      e.Set = False;
    };
}

StructParens {
  e.Arg = <ExtractRealParens Plain e.Arg>; 
}

ExtractRealParens {
 Plain e.x'('e.y')'e.z
 , e.y : {
   e.y1'('e.y2
   , <ExtractRealParens Left () e.y2> : 
  {() e.v2
    = <ExtractRealParens Plain e.x'('e.y1 (e.v2) e.z>;
   (e.v1'(') e.v2
    = <ExtractRealParens Plain e.x'('e.y1'('e.v1 (e.v2) e.z>;
  };
   e.other = <ExtractRealParens Plain e.x (e.y) e.z>;
 };
 Left (e.drop) e.y
 , e.y : 
  {e.y1'('e.y2
     = <ExtractRealParens Left (e.drop e.y1'(')e.y2>;
   e.z = (e.drop) e.y;
  };
 Plain e.Rest = e.Rest;
}

ChooseMax {
 s.Val1 s.Val2
 , <Compare s.Val1 s.Val2> :
 {'+' = s.Val1;
  s.Any = s.Val2;
 };
}

/*
  <Subst (e.Substs) (e.Expr)>
    == (e.SubstExpr)
*/
Subst {
  (e.Substs) (e.Expr)
    , e.Substs : {
      t.Subst e.RestSubsts
        = <Subst (e.RestSubsts) (<Subst-Aux t.Subst e.Expr>)>;

      /* No substs */ = (e.Expr);
    };
}

Subst-Aux {
  t.Subst e.Expr
    , t.Subst : (assign (e.Old) (e.New))
    , e.Expr : {
      e.L e.Old e.R = e.L e.New <Subst-Aux t.Subst e.R>;

      /* Nothing to substitute. */
      e.Other = e.Other;
    };
}

/*
  <GenSubst (e.Old) (e.New)>
    == t.Subst
*/
GenSubst {
  (e.Old) (e.New) = (assign (e.Old) (e.New));
}

/*
  <GetNonEmptyVars e.Constraints>
    == e.NonEmptyVars
*/
GetNonEmptyVars {
  e.L (OR (not empty (Var s.X))) e.R = (Var s.X) <GetNonEmptyVars e.R>;

  /* No appropriate disjuncts left */
  e.Other = /* EMPTY */;
}

/*
  <GetVars (e.Elems)>
    == e.Vars
*/
GetVars {
  (e.L (Var s.X) e.R) = (Var s.X) <GetVars (e.R)>;

  (e.Other) = /* EMPTY */;
}

GetConsts {
  (t.Comp e.RestComps)
    , t.Comp : {
      (Var s.Name) = <GetConsts (e.RestComps)>; /* Ignore vars. */

      (s.Name s.Number) = t.Comp <GetConsts (e.RestComps)>;
      
      e.Other = <Prout 'GetConsts: Invalid component ' e.Other>;
    };

  (/* No more comps */) = /* EMPTY */;

  e.Other = <Prout 'GetConsts: Invalid input ' e.Other>;
}

/*
  <TrimEquation s.Mode t.Equation>
    == t.TrimmedEquation
*/
TrimEquation {
  s.Mode t.Equation
    , Left Right : e.L s.Mode e.R /* verifying the mode */
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.IndexEqs))
    , <MapCall Curry (Take s.Mode) (e.LHS) (e.RHS)> : {
      /* Both equation parts are not empty */
      (t.Elem1 e.LHS1) (t.Elem2 e.RHS1)
        , <AreElementsEqual t.Elem1 t.Elem2 (e.IndexEqs)> : {
          True
            = <TrimEquation
                s.Mode
                ((AreEqual (e.LHS1) (e.RHS1)) (e.Constraints) (e.IndexEqs))
              >;

          False = t.Equation;
        };

      /* At least one part of the equation is empty */
      e.Other = t.Equation;
    };
  
  e.Other = <Prout 'TrimEquation: Invalid input ' e.Other>;
}

/*
  <AreElementsEqual (e.Comp1) (e.Comp2) (e.IndexEqs)>
    == True
    == False
*/
AreElementsEqual {
  (e.Comp1) (e.Comp2) (e.IndexEqs)
    , (e.Comp1) (e.Comp2) : {
      (s.Type s.Value) (s.Type s.Value) = True;

      (Var s.Value1) (Var s.Value2) = False;

      (s.Type s.Value1) (s.Type s.Value2)
        , <MapCall Curry (GetIndexEq (e.IndexEqs)) (e.Comp1) (e.Comp2)> : {
          ((e.Comp1) is (e.RHS)) ((e.Comp2) is (e.RHS)) = True;
              
          e.DifferentIndexEqs = False;
        };
        
      (s.Type1 s.Value1) (s.Type2 s.Value2) = False;

      e.Other = <Prout 'AreElementsEqual: Invalid components ' e.Other>;
    };

  e.Other = <Prout 'AreElementsEqual: Invalid input ' e.Other>;
}

VarAlphabet {
  = <MapCall
      Plain
      GenVar
      <LatinCapitalLetters>
    >;
}

GenVar {
  s.Name = (Var s.Name);
}

/*
  Returns the First-elements of the constant.

  <GetFirst t.Const (e.Conditions)>
    == e.FirstElems
*/
GetFirst {
  t.Const (e.Conditions)
    , e.Conditions : {
      e.L (t.Const is (t.FirstElem e.Details) e.Elems) e.R
        = t.FirstElem <GetFirst t.FirstElem (e.L e.R)>;

      /* No condition for the constant. */
      e.Conditions = /* EMTPY */;
    };
}

/*
  Returns the Last-elements of the constant.

  <GetLast t.Const (e.Conditions)>
    == e.LastElems
*/
GetLast {
  t.Const (e.Conditions)
    , e.Conditions : {
      e.L (t.Const is e.Elems (t.LastElem e.Details)) e.R
        = t.LastElem <GetLast t.LastElem (e.L e.R)>;
      
      /* No condition for the constant. */
      e.Conditions = /* EMPTY */;
    };
}

/*
  <GenSubstDenial t.ElementarySubst>
    == t.Restriction
*/
GenSubstDenial {
  (assign (t.Var) (e.NewValue))
    , e.NewValue : {
      t.Var t.Const = (not t.Const ends t.Var);

      t.Const t.Var = (not t.Const starts t.Var);

      /* EMPTY */ = (not empty t.Var);
    };
}

/*
  <CartesianProductOfOptionSets e.OptionSets>
    == (e.MultipliedOptions)
*/
CartesianProductOfOptionSets {
  (e.Set1) (e.Set2) e.RestSets
    = <CartesianProductOfOptionSets 
        <CartesianProduct Overlap (e.Set1) (e.Set2)> e.RestSets
      >;

  (e.Set) = (e.Set);

  /* No sets */ = (/* EMPTY */);
}

/*
  Cartesian product of two arbitary sets with custom pair processing function.
  
  <CartesianProduct s.ProcessingFunction (e.Set1) (e.Set2)>
    == (e.MultipliedElements)
*/
CartesianProduct {
  s.ProcessingFunction (e.Set1) (e.Set2)
    = (<MapCall
        Curry
        (CartesianProduct-Aux s.ProcessingFunction (e.Set2))
        e.Set1
      >);
}

CartesianProduct-Aux {
  s.ProcessingFunction (e.Set) t.Elem
    = <MapCall Curry (s.ProcessingFunction t.Elem) e.Set>;
}

/*
  <RemoveRedundantRestrictions
    (e.EqConsts) (e.Conditions) (e.UncheckedConstraints) (e.CheckedConstraints)
  >
    == e.CheckedConstraints
*/
RemoveRedundantRestrictions {
  (e.EqConsts) (e.Conditions) (e.UncheckedConstraints) (e.CheckedConstraints)
    , e.UncheckedConstraints : {
      t.Constraint e.RestConstraints
        , t.Constraint : {
          /* Skipping constraints on emptiness. */
          (OR (not empty t.Var))
            = <RemoveRedundantRestrictions
                (e.EqConsts) (e.Conditions) (e.RestConstraints)
                (e.CheckedConstraints t.Constraint)
              >;
              
          /* Handling prefix (suffix) restrictions */ 
          (OR t.Restr1 e.AnotherRestr)
            , <IsRestrictionRedundant
                t.Restr1 (e.EqConsts) (e.Conditions)
              > : {
              True
                , e.AnotherRestr : {
                  /* EMPTY */ /* removing the disjunct */
                    = <RemoveRedundantRestrictions
                        (e.EqConsts) (e.Conditions) (e.RestConstraints)
                        (e.CheckedConstraints)
                      >;

                  t.Restr2
                    , <IsRestrictionRedundant
                        t.Restr2 (e.EqConsts) (e.Conditions)
                      > : {
                      True /* removing the disjunct */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conditions) (e.RestConstraints)
                            (e.CheckedConstraints)
                          >;
                      
                      False /* removing the first restriction */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conditions) (e.RestConstraints)
                            (e.CheckedConstraints (OR t.Restr2))
                          >;
                    };
                };

              False
                , e.AnotherRestr : {
                  /* EMPTY */
                    /* Saving the constraint */
                    = <RemoveRedundantRestrictions
                        (e.EqConsts) (e.Conditions) (e.RestConstraints)
                        (e.CheckedConstraints t.Constraint)
                      >;

                  t.Restr2
                    , <IsRestrictionRedundant
                        t.Restr2 (e.EqConsts) (e.Conditions)
                      > : {
                      True
                        /* Removing the second restriction. */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conditions) (e.RestConstraints)
                            (e.CheckedConstraints (OR t.Restr1))
                          >;

                      False
                        /* Saving the constraint */
                        = <RemoveRedundantRestrictions
                            (e.EqConsts) (e.Conditions) (e.RestConstraints)
                            (e.CheckedConstraints t.Constraint)
                          >;
                    };
                };
            };
        
        };
        
      /* EMPTY */ = e.CheckedConstraints;
    };
}

/*
  Accepts only the prefix and suffix restrictions.

  <IsRestrictionRedundant t.Restr (e.EqConsts) (e.Conditions)>
    == True
    == False
*/
IsRestrictionRedundant {
  /* s.Action ::= starts | ends */
  (not t.Const s.Action t.Var) (e.EqConsts) (e.Conditions)
    , <IsElemInSet t.Const (e.EqConsts)> : {
      /* The constant is used in the equation. */
      True = False;
      
      False
        , e.Conditions : {
          /* At least one condition has the constant in the right half. */
          e.L (t.DefConst is e.L1 (t.Const e.Details) e.R1) e.R = False;
            
          /* The restriction is redundant. */
          e.Other = True; 
        };
    };
}

/*
  An index equation (condition) is redundant if:
  - a constant in its left half is missing from the equation;
  - all constants in its right half are missing from the equation and they
    are not left halfs of some index equations.

  <RemoveRedundantConditions
    (e.EqConsts) (e.UncheckedConditions) (e.CheckedConditions)
  >
    == e.CheckedConditions
*/
RemoveRedundantConditions {
  (e.EqConsts) (e.UncheckedConditions) (e.CheckedConditions)
    , e.UncheckedConditions : {
      t.Condition e.RestConditions
        , t.Condition : (t.DefConst is e.Elems)
        , <IsElemInSet t.DefConst (e.EqConsts)> : {
          False
            = <RemoveRedundantConditions
                (e.EqConsts) (e.RestConditions) (e.CheckedConditions)
              >;
              
          True
            , <GetConditionConsts t.Condition> : e.ConditionConsts
            , <IntersectSets (e.EqConsts) (e.ConditionConsts)> : {
                /* None of the condition constants are in the equation. */
                /* EMPTY */
                  , <CallTill
                      (/* EMPTY */)
                      Revert
                      (GetCondition (e.UncheckedConditions e.CheckedConditions))
                      e.ConditionConsts
                    > : {
                      /* EMPTY */
                        = <RemoveRedundantConditions
                            (e.EqConsts) (e.RestConditions)
                            (e.CheckedConditions)
                          >;

                      e.SomeConditions
                        = <RemoveRedundantConditions
                            (e.EqConsts) (e.RestConditions)
                            (e.CheckedConditions t.Condition)
                          >;
                  };

                e.SomeConsts
                  = <RemoveRedundantConditions
                      (e.EqConsts) (e.RestConditions)
                      (e.CheckedConditions t.Condition)
                    >;
            };
        };
        
      /* EMPTY */ = e.CheckedConditions;
    };
}

/*
  TODO: replace GetIndexEq with GetCondition.

  Returns a condition for t.Const or ε, if the condition isn't found.
  
  <GetCondition t.Const (e.Conditions)>
    == t.Condition
    == ε
*/
GetCondition {
  t.Const (e.Conditions)
    , e.Conditions : {
      e.L (t.Const is e.Elems) e.R = (t.Const is e.Elems);

      e.Other = /* EMPTY */;
    };
}

/*
  Returns constants in the right half of the condition.

  <GetConditionConsts t.Condition>
    == e.ConditionConsts
*/
GetConditionConsts {
  (t.DefConst is e.Elems)
    , e.Elems : {
      (t.Const e.Details) e.RestElems
        = t.Const <GetConditionConsts (t.DefConst is e.RestElems)>;
      
      /* No elements (abnormal on the first call) */
      /* EMPTY */ = /* EMPTY */;
    };
}

/*
  <IntersectSets (e.Set1) (e.Set2)>
    == e.Intersection
*/
IntersectSets {
  (e.L1 t.Elem e.R1) (e.L2 t.Elem e.R2)
    = t.Elem <IntersectSets (e.L1 e.R1) (e.L2 e.R2)>;

  /* No common elements */
  (e.Set1) (e.Set2) = /* EMPTY */;
}

/*
  Относительно данной константы A будем называть рестрикцию X != BX зависимой,
  если B принадлежит множеству First(A), и независимой в противном случае.
  
  <IsDependentConstraint (e.Conditions) t.Const t.Constraint>
    == True
    == False
*/
IsDependentConstraint {
  (e.Conditions) t.Const t.Constraint
    , t.Constraint : {
      (OR (not t.PrefixConst starts t.Var))
        = <IsElemInSet
            t.PrefixConst
            (t.Const <GetFirst t.Const (e.Conditions)>)
          >;

      (OR (not t.SuffixConst ends t.Var))
        = <IsElemInSet
            t.SuffixConst
            (t.Const <GetLast t.Const (e.Conditions)>)
          >;
    };
}

SelectConstraints {
  (e.Constraints) s.Mode t.Var
    , s.Mode : {
      Prefix
        , e.Constraints : e.L (OR (not t.PrefixConst starts t.Var)) e.R
        = (OR (not t.PrefixConst starts t.Var))
          <SelectConstraints (e.R) s.Mode t.Var>;
      
      Suffix
        , e.Constraints : e.L (OR (not t.SuffixConst ends t.Var)) e.R
        = (OR (not t.SuffixConst ends t.Var))
          <SelectConstraints (e.R) s.Mode t.Var>;

      Empty
        , e.Constraints : e.L (OR (not empty t.Var)) e.R
        = (OR (not empty t.Var));

      s.AnyMode = /* empty */;
    };
}

/*
  <GenPrefixConstraint t.Var t.Const> == t.PrefixConstraint
*/
GenPrefixConstraint {
  t.Var t.Const = (OR (not t.Const starts t.Var)) 
}

/*
  <GenSuffixConstraint t.Var t.Const> == t.SuffixConstraint
*/
GenSuffixConstraint {
  t.Var t.Const = (OR (not t.Const ends t.Var)) 
}

/*
  <GenEmptyConstraint t.Var> == t.EmptyConstraint
*/
GenEmptyConstraint {
  t.Var = (OR (not empty t.Var)) 
}

/*
  Будем называть уравнение нормальным, если в нём нет совпадающих префиксов и
  суффиксов, избыточных условий и ограничений.

  <NormalizeEq t.Eq> == t.NormalEq
*/
NormalizeEq {
  t.Eq
    , <MapCompose ((TrimEquation Left) (TrimEquation Right)) t.Eq>
    : ((AreEqual (e.NormalLHS) (e.NormalRHS)) (e.Constraints) (e.Conditions))
    , <MapCompose
        (<MapCall Curry (FormTerm GetElems Const) (e.NormalLHS) (e.NormalRHS)>)
        (/* empty */)
      > : (e.Consts)
    , <RemoveRedundantConditions
        (e.Consts) (e.Conditions) (/* empty */)
      > : e.NormalConditions
    , <RemoveRedundantRestrictions
        (e.Consts) (e.NormalConditions) (e.Constraints) (/* empty */)
      > : e.NormalConstraints
    = (
        (AreEqual (e.NormalLHS) (e.NormalRHS))
        (e.NormalConstraints) (e.NormalConditions)
      );
}

/*
  <GetElems s.Mode (e.Elems) (e.SelectedElems)> == t.Elems

  s.Mode ::= Var | Const
*/
GetElems {
  s.Mode (e.Elems) (e.UniqueElems)
    , e.Elems : {
      (Var s.Letter) e.RestElems
        , s.Mode : {
          Var, <IsElemInSet (Var s.Letter) (e.UniqueElems)> : False
            = <GetElems
                s.Mode (e.RestElems) (e.UniqueElems (Var s.Letter))
              >;

          s.Other = <GetElems s.Mode (e.RestElems) (e.UniqueElems)>;
        };

      (s.Letter s.Number) e.RestElems
        , s.Mode : {
          Const, <IsElemInSet (s.Letter s.Number) (e.UniqueElems)> : False 
            = <GetElems
                s.Mode (e.RestElems) (e.UniqueElems (s.Letter s.Number))
              >;

          s.Other = <GetElems s.Mode (e.RestElems) (e.UniqueElems)>;
        };

      /* no elements */ = (e.UniqueElems);
    };
}

/*
  <Pick s.Number e.Equations>
    == t.Equation
*/
$ENTRY Pick {
  1 ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions)) e.RestEquations
    , <SubtractSets
        (<GetUniqueValues Flat <MapCall Plain GetVars (e.LHS) (e.RHS)>>)
        (<GetNonEmptyVars e.Constraints>)
      >
    : (e.VarsForSubst)
    , <MapCall
        Revert
        (GenSubst (/* EMPTY */))
        <MapCall Plain FormTerm e.VarsForSubst>
      >
    : e.Substs
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.LHS) (e.RHS)
      >
    : {
      (e.Half) (e.Half) = Success;

      (e.NewLHS) (e.NewRHS)
        , <MapCall Plain GetConsts (e.NewLHS) (e.NewRHS)> : {
          /* No consts were found */ = NotMinimal;

          e.SomeConsts
            = ((AreEqual (e.NewLHS) (e.NewRHS)) (e.Constraints) (e.Conditions)); 
        };
    };

  s.Number t.Equation e.RestEquations = <Pick <Sub s.Number 1> e.RestEquations>;
}

/*
  <SubstIndex s.Index (e.Subst) (e.Eq)>
    == (e.SubstEq)
*/
$ENTRY SubstIndex {
  s.Index (e.Multiset)
  ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.IndexEqs))
    , <MapCall
        Curry
        (SubstToIndexEq (s.Index (e.Multiset)))
        e.IndexEqs
      >
    : e.SubstIndexEqs
    , <MapCompose
        ((TrimEquation Left) (TrimEquation Right))
        ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.SubstIndexEqs))
      >
    : ((AreEqual (e.TrimmedLHS) (e.TrimmedRHS)) e.Rest)
    , <MapCall
        Curry
        (
          CheckIndexEqToCollapse
          (
            <GetUniqueValues
              Flat
              <GetConsts (e.TrimmedLHS)> <GetConsts (e.TrimmedRHS)>
            >
          )
        )
        e.SubstIndexEqs
      >
    : e.NecessaryIndexEqs
    , <ReplaceRepeatedIndexEqs
        (e.NecessaryIndexEqs)
        (/* No substitutions at start */)
      > : (e.UniqueIndexEqs) (e.Substs)
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.TrimmedLHS) (e.TrimmedRHS)
      > : (e.SubstLHS) (e.SubstRHS)
    = ((AreEqual (e.SubstLHS) (e.SubstRHS)) (e.Constraints) (e.UniqueIndexEqs));
  
  e.Other = <Prout 'SubstIndex: Invalid input ' e.Other>;
}

/*
  <SubstToIndexEq (s.Index (e.Multiset)) (e.IndexEq)> == (e.SubstIndexEq)
*/
SubstToIndexEq {
  (s.Index (e.Multiset)) ((s.Name s.Number) is (e.RHS))
    = (
        (s.Name s.Number)
        is
        (<SumUpComps /* TODO: lexicographic sort */
          <MapCall Curry (SubstToComp (s.Index (e.Multiset))) e.RHS>
        >)
      );
    
  e.Other = <Prout 'SubstToIndexEq: Invalid input ' e.Other>;
}

/*
  <SubstToComp (s.Index (e.Multiset)) (e.Comp)> == (e.SubstComp)
*/
SubstToComp {
  (s.Index (e.Multiset)) (e.Comp)
    , e.Comp : {
      s.Index s.Number = <MapCall Curry (MulComp s.Number) e.Multiset>;

      s.AnotherIndex s.Number = (e.Comp);

      e.Other = <Prout 'SubstToComp: Invalid component ' e.Other>;
    };
    
  e.Other = <Prout 'SubstToComp: Invalid input ' e.Other>;
}

/*
  <MulComp s.Multiplier (e.Comp)> == (e.MulComp)
*/
MulComp {
  s.Multiplier (s.Index s.Number) = (s.Index <Mul s.Multiplier s.Number>);
  
  e.Other = <Prout 'MulComp: Invalid input ' e.Other>;
}

/*
  <SumUpComps e.Comps> == e.SummedUpComps
*/
SumUpComps {
  e.U1 (s.Index s.Number1) e.U2 (s.Index s.Number2) e.U3
    = e.U1 e.U2 (s.Index <Add s.Number1 s.Number2>) <SumUpComps e.U3>;
    
  e.SummedUpComps = e.SummedUpComps;
}

/*
  <GetIndexEq (e.IndexEqs) (e.Comp)>
    == (e.IndexEq)
    == ε
*/
GetIndexEq {
  ((e.IndexEq) e.RestIndexEqs) (e.Comp)
    , e.IndexEq : {
      (e.Comp) is (e.RHS) = (e.IndexEq);

      e.AnotherIndexEq = <GetIndexEq (e.RestIndexEqs) (e.Comp)>;
    };

  /* Abnormal case */
  (/* No more index equations */) (e.Comp) = /* EMPTY */;
}

/*
  <CheckIndexEqToCollapse (e.Consts) (e.IndexEq)>
    == (e.IndexEq)
    == ε
*/
CheckIndexEqToCollapse {
  (e.U1 (e.Comp) e.U2) ((e.Comp) is (e.RHS)) = ((e.Comp) is (e.RHS));
    
  (e.Consts) (e.NotInvolvedIndexEq) = /* EMPTY */;

  e.Other = <Prout 'CheckIndexEqToCollapse: Invalid input ' e.Other>;
}

/*
  <ReplaceRepeatedIndexEqs (e.IndexEqs) (e.Substs)>
    == (e.ReplacedIndexEqs) (e.Substs)
*/
ReplaceRepeatedIndexEqs {
  (
    e.U1
    ((e.Comp1) is (e.RHS))
    e.U2
    ((e.Comp2) is (e.RHS))
    e.U3
  )
  (e.Substs) 
    = <ReplaceRepeatedIndexEqs
        (e.U1 ((e.Comp1) is (e.RHS)) e.U2 e.U3)
        (<GenSubst ((e.Comp2)) ((e.Comp1))> e.Substs)
      >;
      
  (e.UniqueIndexEqs) (e.Substs) = (e.UniqueIndexEqs) (e.Substs);
  
  e.Other = <Prout 'ReplaceRepeatedIndexEqs: Invalid input ' e.Other>;
}

/*
  <PairComp t.ReplacingConst t.Const1 t.Const2 t.Equation>
    == t.NewReplacingConst (e.Equations)
*/
$ENTRY PairComp {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    = <GetNewConst t.ReplacingConst>
      (
        <HandleEmptySubsts
          t.ReplacingConst t.Const1 t.Const2 t.Equation
        >
      );
}

/*
  If an essentially empty substitution is possible, recursively calls itself
  with an applied and not applied substitution equations. Otherwise, transfers
  control to the `HandleNonEmptySubsts` function.
  
  <HandleEmptySubst
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    /* Calling `GetEmptySubst` is quite expensive, so here's
       used `CallTill` not to make redundant calculations with `MapCall` */
    , <CallTill
        (/* EMPTY */)
        Curry
        (
          GetEmptySubst
          t.Const1 t.Const2 (e.Constraints)
        )
        (e.LHS) (e.RHS)
      >
    : {
      /* Found an essentially empty substitution */
      t.Subst
        = /* Calling with performed substitution */
          <HandleEmptySubsts 
            t.ReplacingConst t.Const1 t.Const2
            (
              (
                AreEqual
                <MapCall Curry (Subst (t.Subst)) (e.LHS) (e.RHS)>
              )
              (e.Constraints)
              (e.Conditions)
            )
          >
          /* Calling with not performed substitution */
          <HandleEmptySubsts
            t.ReplacingConst t.Const1 t.Const2
            (
              (AreEqual (e.LHS) (e.RHS))
              (e.Constraints (OR <GenSubstDenial t.Subst>))
              (e.Conditions)
            )
          >;
      
      /* No essentially empty substitution is found. */
      /* EMPTY */
        = <HandleNonEmptySubsts
            t.ReplacingConst t.Const1 t.Const2 t.Equation
          >;
    };
}

/*
  Returns any essentially empty substitution possible in the given equation
  half. If no such substitution is found, returns ε.
  
  <GetEmptySubst
    t.Const1 t.Const2 (e.Constraints) (e.EquationHalf)
  >
    == t.Subst
    == ε
*/
GetEmptySubst {
  t.Const1 t.Const2 (e.Constraints) (e.EquationHalf)
    /* Saving the result of frequently called functions */
    , <VarAlphabet> : e.Vars
    , <GetNonEmptyVars e.Constraints> : e.NonEmptyVars
    , e.EquationHalf : {
      e.L t.Const1 e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            (e.Vars)
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;
        
      e.L t.Const1 e.M (Var s.X) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;

      e.L (Var s.X) e.M t.Const2 e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;

      e.L (Var s.X) e.M  (Var s.Y) e.R
        , <IsEmpty e.M> : False
        , <IsWordInAlphabet
            (e.M)
            <SubtractSets (e.Vars) ((Var s.X) (Var s.Y))>
          >
        : True
        , <SubtractSets
            (<GetUniqueValues Flat e.M>)
            (e.NonEmptyVars)
          >
        : (t.SubstVar e.RestVars)
        = <GenSubst (t.SubstVar) (/* EMPTY */)>;
        
      /* No essentially empty substitutions for this half of the equation */
      e.Other = /* EMPTY */;
    };
}

/* Finds and applies essentially non-empty substitutions to the equation. 
  
  <HandleNonEmptySubsts
    t.ReplacingConst t.Const1 t.Const2 t.Equation
  >
    == e.Equations 
*/
HandleNonEmptySubsts {
  t.ReplacingConst t.Const1 t.Const2 t.Equation
    , t.Equation : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    , <GetNonEmptySubsts /* substitutions for the right half */
        t.Const1 t.Const2 (e.Constraints) (e.Conditions)
        <GetNonEmptySubsts /* substitutions for the left half */
          t.Const1 t.Const2 (e.Constraints) (e.Conditions)
          (/* No discovered elementary substitutions at start */)
          (/* No discovered composite substitutions at start */)
          (e.LHS)
        >
        (e.RHS)
      > : (e.ElementarySubsts) (e.CompositeSubsts)
    , <CartesianProductOfOptionSets
        <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
      >
    : (e.MultipliedOptions) /* what if no options initially? */
    , <MapCall
        Curry
        (ProcessOption (e.Conditions))
        e.MultipliedOptions
      > : {
      /* No implicit occurences. Applying empty option to the equation. */
      /* EMPTY */
        = <ApplyOption
            t.ReplacingConst t.Const1 t.Const2 t.Equation
            ((/* No substitutions */)(/* No constraints */))
          >;

      e.ProcessedOptions
        = <MapCall
            Curry
            (ApplyOption t.ReplacingConst t.Const1 t.Const2 t.Equation)
            e.ProcessedOptions
          >;
    };
}

/*
  Returns essentially non-empty substitutions for the given equation half.
  There are no impossible substitutions among returned.
  
  <GetNonEmptySubst
    t.Const1 t.Const2 (e.Constraints) (e.Conditions)
    (e.DiscoveredElementarySubsts) (e.DiscoveredCompositeSubsts) (e.Elems)
  >
    == e.Substs
*/
GetNonEmptySubsts {
  t.Const1 t.Const2 (e.Constraints) (e.Conditions)
  (e.ElementarySubsts) (e.CompositeSubsts) (e.Elems)
    , e.Elems : {
      (Var s.X) (Var s.Y) e.RestElems
        , <GenSubst ((Var s.X)) ((Var s.X) t.Const1)> : t.Subst1
        , <GenSubst ((Var s.Y)) (t.Const2 (Var s.Y))> : t.Subst2
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.Y) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts (t.Subst1 t.Subst2))
            ((Var s.Y) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet (t.Subst1 t.Subst2) (e.CompositeSubsts)> : {
            /* The substitution is already processed. */
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.ConstX ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.ConstX
                      (t.Const1 <GetLast t.Const1 (e.Conditions)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False
                        ,  e.L e.R : {
                          e.L1 (OR (not t.ConstY starts (Var s.Y))) e.R1
                            , <IsElemInSet
                                t.ConstY
                                (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                              > : {
                                /* The substitution is impossible. */
                                True = <UnwrapCalls t.SkipSubst>;

                                False = <UnwrapCalls t.AddSubst>;
                              };
                          
                          /* No constraint on the substitution. */
                          e.L e.R = <UnwrapCalls t.AddSubst>;
                        };
                    };

                /* No constraint on the first substitution. */
                e.L (OR (not t.ConstY starts (Var s.Y))) e.R
                  , <IsElemInSet
                      t.ConstY
                      (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                    > : {
                      /* The substitution is impossible. */
                      True = <UnwrapCalls t.SkipSubst>;

                      False = <UnwrapCalls t.AddSubst>;
                    };

                /* No constraints on the substitutions. */
                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Const1 (Var s.X) e.RestElems
        , <GenSubst ((Var s.X)) (t.Const2 (Var s.X))> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            ((Var s.X) e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.Const starts (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };
        
      (Var s.X) t.Const2 e.RestElems
        , <GenSubst ((Var s.X)) ((Var s.X) t.Const1)> : t.Subst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            (e.RestElems) /* can skip t.Const2 */
          ) : t.SkipSubst
        , (GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts t.Subst) (e.CompositeSubsts)
            (e.RestElems)
          ) : t.AddSubst
        , <IsElemInSet t.Subst (e.ElementarySubsts)> : {
            True = <UnwrapCalls t.SkipSubst>;
                
            False
              , e.Constraints : {
                e.L (OR (not t.Const ends (Var s.X))) e.R
                  , <IsElemInSet
                      t.Const
                      (t.Const1 <GetLast t.Const1 (e.Conditions)>)
                    > : {
                      True = <UnwrapCalls t.SkipSubst>;
                    
                      False = <UnwrapCalls t.AddSubst>;
                    };

                e.Constraints = <UnwrapCalls t.AddSubst>;
              };
        };

      t.Elem1 t.Elem2 e.RestElems
        = <GetNonEmptySubsts
            t.Const1 t.Const2 (e.Constraints) (e.Conditions)
            (e.ElementarySubsts) (e.CompositeSubsts)
            (t.Elem2 e.RestElems)
          >;

      e.OneOrNoTerm = (e.ElementarySubsts) (e.CompositeSubsts);
    };
}

/*
  <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
    == e.OptionSets
*/
GenOptionSets {
  (e.ElementarySubsts) (e.CompositeSubsts)
    , <GetUniqueValues
        Flat
        <MapCall
          Revert
          (GetSpecialSubsts (e.ElementarySubsts))
          e.CompositeSubsts
        >
      >
    : e.SpecialSubsts
    , <SubtractSets (e.ElementarySubsts) (e.SpecialSubsts)>
    : (e.UnprocessedElementarySubsts)
    = <MapCall
        Revert
        (GenCompositeOptionSet (e.SpecialSubsts))
        e.CompositeSubsts
      >
      <MapCall
        Plain
        GenElementaryOptionSet
        e.UnprocessedElementarySubsts
      >;
}

/*
  For the equation, we call an essential elementary substitution "special"
  if it is present in some essential composite substitution.

  Returns special substitutions of the given composite substitution.
  
  <GetSpecialSubsts t.CompositeSubst (e.ElementarySubsts)>
    == e.SpecialSubsts
*/
GetSpecialSubsts {
  (t.Subst1 t.Subst2) (e.ElementarySubsts)
    , e.ElementarySubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is special too. */
          e.L1 t.Subst2 e.R1 = t.Subst1 t.Subst2;

          /* Only the first substitution is special. */
          e.Other = t.Subst1;
        };

      /* Only the second substitution is special. */
      e.L t.Subst2 e.R = t.Subst2;

      /* None of the substitutions are special. */
      e.Other = /* EMPTY */;
    };
}

/*
  We will call an option set composite if it is obtained from a composite
  substitution. 
  
  <GenCompositeOptionSet t.CompositeSubst (e.SpecialSubsts)>
    == e.OptionSet
*/
GenCompositeOptionSet {
  (t.Subst1 t.Subst2) (e.SpecialSubsts)
    , e.SpecialSubsts : {
      /* The first substitution is special. */
      e.L t.Subst1 e.R
        , e.L e.R : {
          /* The second substitution is special too. */
          e.L1 t.Subst2 e.R1
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
                (
                  (t.Subst2)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
              );

          /* Only the first substitution is special. */
          e.Other
            = (
                (
                  (t.Subst1 t.Subst2)
                  (/* No constraints */)
                )
                (
                  (t.Subst1)
                  (
                    (OR <GenSubstDenial t.Subst2>)
                  )
                )
                (
                  (/* No substitutions */)
                  (
                    (OR <GenSubstDenial t.Subst1>)
                  )
                )
              );
        };

      /* Only the second substitution is special. */
      e.L t.Subst2 e.R
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (t.Subst2)
              (
                (OR <GenSubstDenial t.Subst1>)
              )
            )
            (
              (/* No substitutions */)
              (
                (OR <GenSubstDenial t.Subst2>)
              )
            )
          );

      /* None of the substitutions are special. */     
      e.Other
        = (
            (
              (t.Subst1 t.Subst2)
              (/* No constraints */)
            )
            (
              (/* No substitutions */)
              (
                (
                  OR
                  <GenSubstDenial t.Subst1>
                  <GenSubstDenial t.Subst2>
                )
              )
            )
          );
    };
}

/*
  We will call an option set elementary if it is obtained from an elementary
  substitution. 
  
  <GenElementaryOptionSet t.ElementarySubst>
    == e.OptionSet
*/
GenElementaryOptionSet {
  t.Subst
    = (
        (
          (t.Subst)
          (/* No constraints */)
        )
        (
          (/* No substitutions */)
          (
            (OR <GenSubstDenial t.Subst>)
          )
        )
      );
}

/*
  Removes duplicates, redundant constraints and checks the option for
  consistency.
  
  <ProcessOption (e.Conditions) t.Option>
    == t.ProcessedOption
    == ε
*/
ProcessOption {
  (e.Conditions) ((e.Substs) (e.Constraints))
    , <MapCall
        Curry
        (GetUniqueValues Wrap)
        (e.Substs) (e.Constraints)
      > : (e.UniqueSubsts) (e.UniqueConstraints)
    , <RemoveTrivialConstraints
        (e.UniqueConstraints)
        (e.Conditions)
      > : e.NecessaryConstraints
    = <FixOptionConsistency
        ((e.UniqueSubsts) (e.NecessaryConstraints))
        (/* No checked substitutions at start */)
        (e.Conditions)
      >;
}

/*
  Removes trivially performed non-trivial disjuncts.
  
  <RemoveTrivialConstraints (e.Constraints) (e.Conditions)>
    == e.NecessaryConstraints
*/
RemoveTrivialConstraints {
  (e.Constraints) (e.Conditions)
    , e.Constraints : {
      e.L (OR (not t.Const1 ends t.VarX) (not t.Const2 starts t.VarY)) e.R
        , e.L e.R : {
          e.L1 (OR (not t.ConstX ends t.VarX)) e.R2
            , <IsElemInSet t.ConstX
                (t.Const1 <GetLast t.Const1 (e.Conditions)>)
              > : True /* found stronger restriction */
            = e.L <RemoveTrivialConstraints (e.R) (e.Conditions)>;
                
          e.L1 (OR (not t.ConstY starts t.VarY)) e.R2
            , <IsElemInSet
                t.ConstY
                (t.Const2 <GetFirst t.Const2 (e.Conditions)>)
              > : True
            = e.L <RemoveTrivialConstraints (e.R) (e.Conditions)>;

          e.L e.R /* cannot say whether the disjunct is redundant or not */
            = e.L (OR (not t.Const1 ends t.VarX) (not t.Const2 starts t.VarY))
              <RemoveTrivialConstraints (e.R) (e.Conditions)>;
        };
        
      e.TrivialDisjuncts = e.TrivialDisjuncts;
    };
}

/*
  Checks an option for consistency and fixes avoidable contradictions
  whenever necessary. If an unavoidable contradiction is found, returns ε.
  Otherwise, returns the processed option.
  
  <FixOptionConsistency t.Option (e.CheckedSubsts) (e.Conditions)>
    == t.FixedOption
    == ε
*/
FixOptionConsistency {
  ((e.UncheckedSubsts) (e.Constraints)) (e.CheckedSubsts) (e.Conditions)
    , e.UncheckedSubsts : {
      (assign (t.Var) (t.Var t.Const)) e.RestSubsts /* suffix substitution */
      , e.Constraints : {
        e.L (OR (not t.RestrConst ends t.Var) e.AnotherRestr) e.R
          , <IsElemInSet
              t.RestrConst
              (t.Const <GetLast t.Const (e.Conditions)>)
            > : True
          , e.AnotherRestr : {
            /* EMPTY */ = /* EMPTY */; /* unavoidable contradiction */

            t.Restr /* force another restriction to be executed */
              = <FixOptionConsistency
                  ((e.UncheckedSubsts) (e.L (OR t.Restr) e.R))
                  (e.CheckedSubsts) (e.Conditions)
                >;
          };
        
        /* No constraints on the substitution. */
        e.CheckedConstraints
          = <FixOptionConsistency
              ((e.RestSubsts) (e.CheckedConstraints))
              (e.CheckedSubsts (assign (t.Var) (t.Var t.Const)))
              (e.Conditions)
            >;
      };

      (assign (t.Var) (t.Const t.Var)) e.RestSubsts /* prefix substitution */
        , e.Constraints : {
          e.L (OR e.AnotherRestr (not t.RestrConst starts t.Var)) e.R
            , <IsElemInSet
                t.RestrConst
                (t.Const <GetFirst t.Const (e.Conditions)>)
              > : True
            , e.AnotherRestr : {
              /* EMPTY */ = /* EMPTY */;

              t.Restr
                = <FixOptionConsistency
                    ((e.UncheckedSubsts) (e.L (OR t.Restr) e.R))
                    (e.CheckedSubsts) (e.Conditions)
                  >;
            };

          e.CheckedConstraints
            = <FixOptionConsistency
                ((e.RestSubsts) (e.CheckedConstraints))
                (e.CheckedSubsts (assign (t.Var) (t.Const t.Var)))
                (e.Conditions)
              >;
        };
        
      /* All the substitutions are checked. */
      /* EMPTY */ = ((e.CheckedSubsts) (e.Constraints));
    };
}

/*
  Applies option substitutions to the equation (also adds corresponding index
  equation) and appends the option constraints to the equation constraints.
  Thereafter trimmes this equation, removes redundant elements and modifies
  constraints.
  
  <ApplyOption t.ReplacingConst t.Const1 t.Const2 t.Equation t.Option>
    == t.NewEquation
*/
ApplyOption {
  t.ReplacingConst t.Const1 t.Const2
  ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
  ((e.Substs) (e.NewConstraints))
    , <MapCall /* replacing the pairs with the new const */
        Curry
        (Subst (<GenSubst (t.Const1 t.Const2) (t.ReplacingConst)>))
        <MapCall /* applying the option substitutions */
          Curry
          (Subst (e.Substs))
          (e.LHS) (e.RHS)
        >
      > : (e.SubstLHS) (e.SubstRHS)
    , <MapCompose
        ((TrimEquation Left) (TrimEquation Right))
        ((AreEqual (e.SubstLHS) (e.SubstRHS)) (e.Constraints) (e.Conditions))
      > : ((AreEqual (e.TrimmedLHS) (e.TrimmedRHS)) e.Rest)
    , <GetUniqueValues
        Flat
        <MapCall Plain GetConsts (e.TrimmedLHS) (e.TrimmedRHS)>
      >: e.EqConsts
    , <RemoveRedundantConditions
        (e.EqConsts)
        (
          e.Conditions
          (t.ReplacingConst is (t.Const1 (const 1)) (t.Const2 (const 1)))
        )
        (/* EMPTY */)
      > : e.NecessaryConditions 
    , <RemoveRedundantRestrictions
        (e.EqConsts) (e.NecessaryConditions) (e.Constraints) (/* EMPTY */)
      > : e.NecessaryConstraints
    , <ModifyRestrictions
        (e.Substs) (e.NecessaryConstraints e.NewConstraints)
        (e.NecessaryConditions)
      > : e.ModifiedConstraints
    =
      (
        (AreEqual (e.TrimmedLHS) (e.TrimmedRHS))
        (e.ModifiedConstraints) (e.NecessaryConditions)
      );
}

/*
  TODO: fix the cycling

  Modifies constraints taking into account the substitutions.
  
  <ModifyRestrictions (e.Substs) (e.Constraints) (e.Conditions)>
    == e.ModifiedConstraints
*/
ModifyRestrictions {
  (e.Substs) (e.Constraints) (e.Conditions)
    , e.Substs : {
      (assign (t.Var) (t.Const t.Var)) e.RestSubsts
        , e.Constraints : { /* the order of the rules is important here */
          e.L (OR (not empty t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;

          /* Thanks to the GetNonEmptySubsts the t.PrefixConst is definitely
             not in the First(t.Const) set. */
          e.L (OR (not t.PrefixConst starts t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;

          e.L (OR t.SuffixRestr (not t.PrefixConst starts t.Var)) e.R
            , <IsElemInSet
                t.PrefixConst
                (<GetFirst t.Const (e.Conditions)>)
              > : {
              True /* forcing the suffix restriction to be executed */
                = <ModifyRestrictions
                    (e.RestSubsts) /* pay attention that we're moving on */
                    (e.L (OR t.SuffixRestr) e.R) (e.Conditions)
                  >;

              False /* cannot say anything definite, moving on */
                = <ModifyRestrictions
                    (e.RestSubsts) (e.Constraints) (e.Conditions)
                  >;
            };

          e.Other /* moving on */
            = <ModifyRestrictions
                (e.RestSubsts) (e.Constraints) (e.Conditions)
              >;
        };
      
      (assign (t.Var) (t.Var t.Const)) e.RestSubsts
        , e.Constraints : {
          e.L (OR (not empty t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;
            
          e.L (OR (not t.SuffixConst ends t.Var)) e.R
            = <ModifyRestrictions (e.Substs) (e.L e.R) (e.Conditions)>;

          e.L (OR (not t.SuffixConst ends t.Var) t.PrefixRestr) e.R
            , <IsElemInSet
                t.SuffixConst
                (<GetLast t.Const (e.Conditions)>)
              > : {
              True
                = <ModifyRestrictions
                    (e.RestSubsts) (e.L (OR t.PrefixRestr) e.R) (e.Conditions)
                  >;

              False
                = <ModifyRestrictions
                    (e.RestSubsts) (e.Constraints) (e.Conditions)
                  >;
            };

          e.Other
            = <ModifyRestrictions
                (e.RestSubsts) (e.Constraints) (e.Conditions)
              >;
        };
        
      /* EMPTY */ = e.Constraints;
    };
}

/*
  <BlockComp t.BlockConst t.Const s.Index t.Eq>
    == (t.NewConst t.NewIndex t.NewEq)+
*/
$ENTRY BlockComp {
  t.BlockConst t.Const s.Index t.Eq
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    , <MapCompose
        (<MapCall Curry (FormTerm GetElems Var) (e.LHS) (e.RHS)>) (/* empty */)
      > : (e.EqVars)
    , <MapCall
        Curry
        (GenBlockOptionSets (e.Constraints) (e.Conditions) t.BlockConst)
        e.EqVars
      > : e.OptionSets
    , <CartesianProductOfOptionSets e.OptionSets> : (e.MultipliedOptions)
    = <MapCall
        Curry
        (ApplyBlockOption t.BlockConst t.Const s.Index t.Eq)
        e.MultipliedOptions
      >;
}

/*
  <ApplyBlockOption t.BlockConst t.Const s.Index t.Eq t.BlockOption>
    == (t.NewConst t.NewIndex t.NewEq)
*/
ApplyBlockOption {
  t.BlockConst t.Const s.Index t.Eq t.Option
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constraints) (e.Conditions))
    , t.Option : ((e.Substs) (e.AddedConstraints) (e.ExcludedConstraints))
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.LHS) (e.RHS)
      > : (e.SubstLHS) (e.SubstRHS)
    , <MapCall
        Curry
        (JoinBlocks t.BlockConst)
        (e.SubstLHS) (e.SubstRHS)
      > : (e.JoinedLHS) (e.JoinedRHS)
    , <MapCall-Compose
        (NameBlocks t.BlockConst (/* no processed elems at start */))
        (t.Const s.Index (e.Conditions))
        (e.JoinedLHS) (e.JoinedRHS)
      > : (e.NewLHS) (e.NewRHS) t.NewConst s.NewIndex (e.NewConditions)
    , <SubtractSets
        (e.Constraints e.AddedConstraints) (e.ExcludedConstraints)
      > : (e.NewConstraints)
    /* seems the equation is already normal */
    = (
        t.NewConst s.NewIndex
        ((AreEqual (e.NewLHS) (e.NewRHS)) (e.NewConstraints) (e.NewConditions))
      );
}

/*
  Compatible with the MapCall-Compose function.

  <NameBlocks
    t.BlockConst (e.ProcessedElems) ; curried args
    t.Const s.Index (e.Conditions)  ; composition args
    (e.Elems)
  > == t.NewConst t.NewIndex (e.NewConditions) t.NewElem
*/
NameBlocks {
  t.BlockConst (e.ProcessedElems) t.Const s.Index (e.Conditions) (e.Elems)
    , e.Elems : {
      e.L (t.BlockConst e.Indices t.Summand) e.R
        , <NameIndices
            s.Index (e.Indices) (/* no named indices at start */)
          > : s.NewIndex (e.NamedIndices)
        , <MapCall Revert (FormPair 1) e.NamedIndices> : e.Exponents
        = <NameBlocks
            t.BlockConst (e.ProcessedElems e.L t.Const)
            <GetNewConst t.Const> s.NewIndex
            (e.Conditions (t.Const is (t.BlockConst e.Exponents t.Summand)))
            (e.R)
          >;
          
      e.Other = t.Const s.Index (e.Conditions) (e.ProcessedElems e.Elems);
    };
}

/*
  <NameIndices s.Index (e.NamelessIndices) (e.NamedIndices)>
    == s.NewIndex (e.NamedIndices)
*/
NameIndices {
  s.Index (e.NamelessIndices) (e.NamedIndices)
    , e.NamelessIndices : {
      Index e.RestIndices
        = <NameIndices
            <GetNewIndex s.Index> (e.RestIndices) (e.NamedIndices s.Index)
          >;

      /* no nameless indices */ = s.Index (e.NamedIndices);
    };
}

/*
  Accepts the block constant and half of the equation. Compresses extracted
  blocks and explicit blocks of length more than two. 
  
  <JoinBlocks t.BlockConst (e.Elems)> == (e.NewElems)
*/
JoinBlocks {
  t.BlockConst (e.Elems)
    , e.Elems : {
      /* assumed nameless indices, i.e. of the form Index */
      e.L t.BlockConst (t.BlockConst e.Indices (const s.Num)) e.R
        = <JoinBlocks
            t.BlockConst
            (e.L (t.BlockConst e.Indices (const <Add s.Num 1>)) e.R)
          >;
          
      e.L (t.BlockConst e.Indices (const s.Num)) t.BlockConst e.R
        = <JoinBlocks
            t.BlockConst
            (e.L (t.BlockConst e.Indices (const <Add s.Num 1>)) e.R)
          >;
          
      e.L (t.BlockConst e.Indices1 (const s.Num1))
      (t.BlockConst e.Indices2 (const s.Num2)) e.R
        = <JoinBlocks
            t.BlockConst
            (
              e.L
              (t.BlockConst e.Indices1 e.Indices2 (const <Add s.Num1 s.Num2>))
              e.R
            )
          >;
      
      e.L t.BlockConst t.BlockConst e.R
        = <JoinBlocks t.BlockConst (e.L (t.BlockConst (const 2)) e.R)>;

      e.Other = (e.Elems);
    };
}

/*
  <GenBlockOptionSets (e.Constraints) (e.Conditions) t.BlockConst t.Var>
    == e.OptionSets
*/
GenBlockOptionSets {
  (e.Constraints) (e.Conditions) t.BlockConst t.Var
    , <SelectConstraints (e.Constraints) Prefix t.Var> : e.PrefixConstraints
    , <CallTill
        (False) Curry (IsDependentConstraint (e.Conditions) t.BlockConst)
        e.PrefixConstraints
      > : s.HasDependentPrefixConstraints
    , <SelectConstraints (e.Constraints) Suffix t.Var> : e.SuffixConstraints
    , <CallTill
        (False) Curry (IsDependentConstraint (e.Conditions) t.BlockConst)
        e.SuffixConstraints
      > : s.HasDependentSuffixConstraints
    , (t.BlockConst Index (const 0)) : t.Block
    , (t.BlockConst Index (const 1)) : t.NonEmptyBlock
    , <SelectConstraints (e.Constraints) Empty t.Var> : {
      /* EMPTY */
        , <IsEmpty e.PrefixConstraints> : {
          True
            , <IsEmpty e.SuffixConstraints> : {
              /* no constraints */
              True
                = (
                    (
                      (<GenSubst (t.Var) (t.Block)>)
                      (/* no added constraints */)
                      (/* no excluded constraints */)
                    )
                    (
                      (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                      (
                        <GenPrefixConstraint t.Var t.BlockConst>
                        <GenEmptyConstraint t.Var>
                        <GenSuffixConstraint t.Var t.BlockConst>
                      )
                      (/* no excluded constraints */)
                    )
                  );

              False
                , s.HasDependentSuffixConstraints : {
                  /* dependent suffix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (/* empty */)>)
                          (/* no added constraints */)
                          (e.SuffixConstraints)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                          )
                          (/* no excluded constraints */)
                        )
                      );

                  /* independent suffix constraints */
                  False
                    = (
                        (
                          (<GenSubst (t.Var) (t.Block)>)
                          (/* no added constraints */)
                          (e.SuffixConstraints)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (e.SuffixConstraints)
                        )
                      );
                };
            };
          
          False
            , s.HasDependentPrefixConstraints : {
              True
                , <IsEmpty e.SuffixConstraints> : {
                  /* dependent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (/* empty */)>)
                          (/* no added constraints */)
                          (e.PrefixConstraints)
                        )
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                      );
                  
                  False
                    , s.HasDependentSuffixConstraints : {
                      /* dependent both prefix and suffix constraints */
                      True
                        = (
                            (
                              (<GenSubst (t.Var) (/* empty */)>)
                              (/* no added constraints */)
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                            (
                              (/* no substitutions */) 
                              (<GenEmptyConstraint t.Var>)
                              (/* no excluded constraints */)
                            )
                          );
                          
                      /* dependent prefix, independent suffix constraints */
                      False
                        = (
                            (
                              (<GenSubst (t.Var) (/* empty */)>)
                              (/* no added constraints */)
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                            (
                              (/* no substitutions */)
                              (
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>)
                              (
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.SuffixConstraints)
                            )
                          );
                    };
                };

              False
                , <IsEmpty e.SuffixConstraints> : {
                  /* independent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.Block)>)
                          (/* no added constraints */)
                          (e.PrefixConstraints)
                        )
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenEmptyConstraint t.Var>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (e.PrefixConstraints)
                        )
                      );
                      
                  False
                    , s.HasDependentSuffixConstraints : {
                      /* independent prefix, dependent suffix constraints */
                      True
                        = (
                            (
                              (<GenSubst (t.Var) (/* empty */)>)
                              (/* no added constraints */)
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                            (
                              (/* no substitutions */)
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>)
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                              )
                              (e.PrefixConstraints)
                            )
                          );

                      /* independent both prefix and suffix constraints */
                      False
                        = (
                            (
                              (<GenSubst (t.Var) (t.Block)>)
                              (/* no added constraints */)
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                            (
                              (/* no substitutions */) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.SuffixConstraints)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.PrefixConstraints)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var t.Block)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenEmptyConstraint t.Var>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                          );
                    };
                };
            };
        };
      
      t.EmptyConstraint
        , <IsEmpty e.PrefixConstraints> : {
          True
            , <IsEmpty e.SuffixConstraints> : {
              /* no other constraints */
              True
                = (
                    (
                      (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                      (/* no added constraints */)
                      (t.EmptyConstraint)
                    )
                    (
                      (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                      (
                        <GenPrefixConstraint t.Var t.BlockConst>
                        <GenSuffixConstraint t.Var t.BlockConst>
                      )
                      (/* no excluded constraints */)
                    )
                  );

              False
                , s.HasDependentSuffixConstraints : {
                  /* dependent suffix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (<GenPrefixConstraint t.Var t.BlockConst>)
                          (/* no excluded constraints */)
                        )
                      );

                  /* independent suffix constraints */
                  False
                    = (
                        (
                          (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                          (/* no added constraints */)
                          (e.SuffixConstraints t.EmptyConstraint)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (e.SuffixConstraints)
                        )
                      );
                };
            };
          
          False
            , s.HasDependentPrefixConstraints : {
              True
                , <IsEmpty e.SuffixConstraints> : {
                  /* dependent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                      );
                  
                  False
                    , s.HasDependentSuffixConstraints : {
                      /* dependent both prefix and suffix constraints */
                      True
                        = (
                            (
                              (/* no substitutions */) 
                              (/* no added constraints */)
                              (/* no excluded constraints */)
                            )
                          );
                          
                      /* dependent prefix, independent suffix constraints */
                      False
                        = (
                            (
                              (/* no substitutions */)
                              (<GenSuffixConstraint t.Var t.BlockConst>)
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>)
                              (<GenSuffixConstraint t.Var t.BlockConst>)
                              (e.SuffixConstraints)
                            )
                          );
                    };
                };

              False
                , <IsEmpty e.SuffixConstraints> : {
                  /* independent prefix constraints */
                  True
                    = (
                        (
                          (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                          (/* no added constraints */)
                          (e.PrefixConstraints t.EmptyConstraint)
                        )
                        (
                          (<GenSubst (t.Var) (t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (/* no excluded constraints */)
                        )
                        (
                          (<GenSubst (t.Var) (t.Block t.Var t.Block)>)
                          (
                            <GenPrefixConstraint t.Var t.BlockConst>
                            <GenSuffixConstraint t.Var t.BlockConst>
                          )
                          (e.PrefixConstraints)
                        )
                      );
                      
                  False
                    , s.HasDependentSuffixConstraints : {
                      /* independent prefix, dependent suffix constraints */
                      True
                        = (
                            (
                              (/* no substitutions */)
                              (<GenPrefixConstraint t.Var t.BlockConst>)
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>)
                              (<GenPrefixConstraint t.Var t.BlockConst>)
                              (e.PrefixConstraints)
                            )
                          );

                      /* independent both prefix and suffix constraints */
                      False
                        = (
                            (
                              (<GenSubst (t.Var) (t.NonEmptyBlock)>)
                              (/* no added constraints */)
                              (
                                e.PrefixConstraints e.SuffixConstraints
                                t.EmptyConstraint
                              )
                            )
                            (
                              (/* no substitutions */) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (/* no excluded constraints */)
                            )
                            (
                              (<GenSubst (t.Var) (t.Var t.Block)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.SuffixConstraints)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.PrefixConstraints)
                            )
                            (
                              (<GenSubst (t.Var) (t.Block t.Var t.Block)>) 
                              (
                                <GenPrefixConstraint t.Var t.BlockConst>
                                <GenSuffixConstraint t.Var t.BlockConst>
                              )
                              (e.PrefixConstraints e.SuffixConstraints)
                            )
                          );
                    };
                };
            };
        };
    };
}

